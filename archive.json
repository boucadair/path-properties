{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2022-05-22T00:35:32.346975+00:00",
  "repo": "panrg/path-properties",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "MDU6SXNzdWU0MTA3MjE5ODk=",
      "title": "Formalize definition of a path",
      "url": "https://github.com/panrg/path-properties/issues/1",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "theri"
      ],
      "labels": [],
      "body": "We need to provide (at least) one formal definition of what a path is.\r\nIs it defined on a flow level, i.e., the hops that a set of packets traverses? Or only the hops that one individual packet traverses?\r\n\r\nFor this, we should look at the definitions in:\r\n\r\n- IPPM\r\n- ATM\r\n- RFC 8175 (MANET Dynamic Link Exchange Protocol)",
      "createdAt": "2019-02-15T11:17:20Z",
      "updatedAt": "2019-11-04T10:49:57Z",
      "closedAt": "2019-11-04T10:49:57Z",
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "IPPM, in RFC 2330 (Framework for IP Performance Metrics), defines a path as a sequence of links and routers, with two hosts at the end. Each pair of (link, host) is a 'hop'.\r\nSo it is a unidirectional concept which does not depend on a packet, but a packet can take one specific path.\r\nThis is probably a good starting point for our definition...",
          "createdAt": "2019-02-15T14:57:04Z",
          "updatedAt": "2019-02-15T14:57:04Z"
        },
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "I wrote this definition of a path at IETF 103 without looking at existing definitions in other IETF documents, but it is similar to the RFC2330 definition. This definition is at the flow level, but it might be more clear to define a path for individual packets.\r\n\r\nA \"path\" is defined as the set of the devices and links between two endpoints that can be traversed by a set of packets at specific points in time. Depending on which layer the \"path\" is looked at, devices, links, and their properties might differ. Devices may be hidden, and a set of links may be abstracted into a single link. The lifetime of a \"path\" overlaps with the lifetime of the corresponding connection but is not restricted to it.\r\n\r\nA \"path\" can be classified by timescale into a \"measured path\", based on concrete previous and current measurements, and a \"potential path\", which is a path with predicted characteristics, possibly including the reliability of such predictions.",
          "createdAt": "2019-02-18T18:07:55Z",
          "updatedAt": "2019-02-18T18:07:55Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, I think it makes sense to first define the \"path\" on a per-packet level. \r\nThen as a second step, we can define multiple packets belonging to one flow (not just connection, but multiple UDP packets with the same source and destination IP address and port as well).\r\nThen we can have packes of one flow taking the same path, and then we can have path properties change or stay the same for multiple packets within one flow.\r\nSo one packet can have a specific one-way latency along the path, and multiple packets of the same flow on the same path can have, e.g., a median one-way latency, or a Round Trip Time.\r\n\r\nI'm not yet sure if we need a distinction into \"measured\" and \"potential\" path -- aren't these more, like, measured properties or predicted properties? \r\nI mean, the path is always there, no matter if packets are sent over it, right? But some properties only exist in relation to packets sent over a path?",
          "createdAt": "2019-02-18T19:50:47Z",
          "updatedAt": "2019-02-18T19:50:47Z"
        },
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "What do you think about this terminology section?\r\nShould we add it before the introduction? (I guess if we add it after, we need to remove any reference to path/property in the introduction and make a more high level introduction)\r\nI tried to structure it accordingly (path -> flow -> property).\r\nMaybe it is better not to define *Connection*, as it may cause confusion between connections and flows. I think we should clearly specify that a path can be defined over different layers and that we only consider end-to-end connections/flows/paths, but I could also add this to the path definition and remove the connection definition.\r\n\r\n# Terminology\r\n\r\nThis section defines a set of terms used throughout this document. In some cases these terms have been used in other contexts with different meanings so this section attempts to describe each term's meaning with respect to the PANRG activities.\r\n\r\nConnection:\r\n: Connections, as used in this draft, incorporate application, transport, network, data link, and physical layer connections between a set of endpoints. Hereinafter, connections refer to bidirectional or unidirectional connections between two endpoints. How concepts of paths and path properties can be extended to other connection models such as one-to-many or many-to-many connections is not described in this draft.\r\n\r\nPath:\r\n: A path element is a device (including the endpoints), or link used to connect two endpoints and transmit information.\r\nA path is defined as an ordered set of path elements that can be traversed by a packet at specific points in time.\r\nFor the sake of simplicity, we use the term packet, typically used at the network layer, to describe bit strings transmitted on any layer.\r\nDepending on which layer the path is looked at, devices, links, and their properties might differ.\r\nDevices may be hidden, and a set of links may be abstracted into a single link.\r\nThe lifetime of a path overlaps with the lifetime of the corresponding connection but is not restricted to it.\r\n\r\nFlow:\r\n: Several packets traversing the same path elements at specific points in time, can be combined into a flow (e.g., all packets sent within a UDP session).\r\nAs a special case, a flow can consist of just one packet.\r\n\r\nProperty:\r\n: A property describes a trait of a set of path elements (e.g., capacity of a link, is device X a firewall, one-way bandwidth which is the minimum of all link bandwidths), or a trait of a flow being sent on a set of path elements (e.g., RTT, one-way delay).\r\nA property is thus described by a tuple containing the ordered set of path elements, the set of packets traversing the path (the flow) or an empty set if no packets are relevant for the property, the type of trait (e.g., bandwidth), and the value of the trait (e.g., 100mbps).\r\n\r\nAggregated Property:\r\n: A property can be aggregated over a set of path elements (e.g., loss rate in network backbone calculated using the individual link loss rates), or over a set of packets (e.g., median one-way latency of all packets during the last second), or over both (e.g., average time spent in buffers in the network backbone).\r\nAggregation can be numerical (average, sum, min, ...), logical (true if all are true, true if at least X are true, ...), or an arbitrary function which maps a set of input properties to an output property.\r\n\r\nMeasured & Potential Property:\r\n: A property can be classified by timescale into a measured property, based on concrete previous and current measurements, and a potential property, which is a property with predicted characteristics, possibly including the reliability of such predictions.",
          "createdAt": "2019-02-26T10:00:39Z",
          "updatedAt": "2019-02-26T10:00:39Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for proposing this.\r\n\r\nCould you make a Pull Request out of this, please? That would make it easier to discuss individual parts of it by referring to specific lines etc., and then it's easier to merge it.\r\n\r\nFirst, about where to put it: I think it's fine to put it after the Introduction and still use the words in the introduction. RFC 2330 does it, for example, so we are allowed, too. ;)\r\n\r\nAbout the definitions:\r\n\r\nI agree that perhaps it's better to not define Connection. Here it is basically defined by itself (\"a Connection is a connection\"), but I mean, what even is a physical layer Connection for example? Is it a single frame sent from one network card to another on a single physical link? This confuses me.\r\n\r\nI think we should start with Path, or maybe with path element, and then we can define Path with it (i.e., instead of \"Devices may be hidden\", write \"Path elements may be hidden\", and instead of \"links can be aggregated\", \"Path element can be aggregated\".\r\nAnd then I thought that the lifetime of a path is just the lifetime of a packet? Or do you mean that the \"physical layer connection\" is just one single packet? Again, I'm confused.\r\n\r\nIn fact I'm still wondering why we need the different layers at all as they are used here. Why not just define path as a set of path elements at the network layer, to be traversed from one endpoint to the other? Then physical layer properties can apply to an individual path element, and transport layer properties can apply to the entire path. And then we can have aggregate properties that apply to a Flow. \r\n\r\nDoes the definition of flow imply that all packets have the same 5-tuple? This would be the case for a single UDP session, but then the packets of this session can easily take different paths through the network.\r\nMaybe it's better to define flow with the 5-tuple, and then say, if multiple packets of the same flow take the same path, we can aggregate their properties? Or do we here completely redefine flow and the example is just incomplete, i.e., the example should be \"all packets sent within a UDP session which traverse the same path elements\"?\r\n\r\nI like the concept of Property and Aggregated Property. \r\nNot sure if we really want to call it \"type\" of the property, because this sounds a lot like \"data type\" to me, maybe it's just the name of the property? \r\n\r\nMinor point:\r\nI think the sentence at the start of the section, \"In some cases these terms have been used in other contexts with different meanings...\", is redundant, because it's obvious. Or, if we must have it, let's not say that we define this for \"the PANRG activities\", but only for this draft.",
          "createdAt": "2019-02-26T19:41:17Z",
          "updatedAt": "2019-02-26T19:41:17Z"
        },
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "I created a pull request #5 \r\n\r\nI removed connection and added a separate definition for path element, which can be a device or link on ANY layer. Then the path is a definition of path elements on the network layer.\r\n\r\nI don't think its useful to define a flow on a 5-tuple since as you said we cannot say anything about the properties of such a flow. I adjusted the example.\r\n\r\nI also think using name instead of type makes it more clear what we mean.\r\n\r\nWhat do you think about measured & potential property? Is it necessary to define it?",
          "createdAt": "2019-03-05T11:27:15Z",
          "updatedAt": "2019-03-05T11:28:27Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed via #5.",
          "createdAt": "2019-03-11T18:10:26Z",
          "updatedAt": "2019-03-11T18:10:26Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Some thoughts on how to revise our definitions:\r\n\r\n- Path elements can be either nodes or links. (Rename \"devices\" to nodes)\r\n- Nodes are devices that implement a protocol on a certain layer (like IPv6 nodes implementing IPv6, see RFC 8200). Not sure if we need to differentiate between nodes which are routers, which forward packets not destined for themselves, and nodes which are hosts. \r\n- Links can connect multiple nodes, not just two. Links can also be virtual (e.g., connecting two nodes like when chaining two service functions)\r\n- A path is a sequence (not \"ordered set\", which apparently means something different than we want) of path elements alternating between nodes and links, starting and ending with a node. Links and nodes have to be adjacent (not sure if that's the correct word)\r\n- Get rid of the \"Path segment\" because segment means something entirely different in SPRING (see RFC 8402). We could have a \"subpath\" similar to RFC 2330 (IPPM), where a subpath is any subsequence of a given path, which is itself a path (i.e., first and last elements are nodes) -- in IPPM, the first and last elements are hosts, but I want subpaths between routers as well.\r\n- Property is a trait of a set of path elements of a path.\r\n- Rename \"Potential property\" to \"Estimated\" or \"Predicted\" property because that makes it clearer what we mean",
          "createdAt": "2019-06-27T09:45:59Z",
          "updatedAt": "2019-06-27T10:01:26Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Now that we've converged on the terms for this revision, I did a first search-and-replace on the old terms in the other sections, see #12. Feel free to add more.",
          "createdAt": "2019-07-04T17:00:47Z",
          "updatedAt": "2019-07-04T17:00:47Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed pre-IETF 105, let's see what PANRG thinks about our updated definitions.",
          "createdAt": "2019-07-08T11:03:28Z",
          "updatedAt": "2019-07-08T11:03:28Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Next round including comments from IETF 105 PANRG session:\r\n\r\n- **Host/Router**: Drop this distinction, at least from our terminology and/or path definition, so we define a path between two nodes and not two hosts. Reason, as pointed out by Alia: Does not adequately capture overlay nodes, overlays are everywhere, and there might be more relevant traffic between the overlay nodes in addition to the end-to-end flow we are considering. Also, the distinction of \"[packets] that are explicitly addressed (not) to [itself]\" in unclear because it differs based on layers. However, we should still be able to talk about \"end hosts\" because we do refer to them quite a lot.\r\n\r\n- **Link**: Make explicit that links are unidirectional, and have bidirectional links be the collection of two links between the same nodes in different directions, as suggested by Nicholas Kuhn.\r\n\r\n- **Path**: Make explicit that paths are not static, but time-dependent, as pointed out by Alia. A sequence of path elements can change from one second to the next - so does a path only exist while its specific sequence of path elements can actually be used to send a packet? (Not sure how to phrase this yet)\r\n\r\n- **Flow**: Change this to essentially just be a set of packets to which path properties can apply, or as Brian suggests, \"an entity made of packets to which the traits of a path or set of subpaths may be applied in a functional sense.\" -- I'm not quite happy with \"entity\" though, why not just set of packets? In any case, our current definition does not work because we want a flow to be able to include packets in two directions, but these packets may not traverse the same subpath, as paths can be asymmetric.",
          "createdAt": "2019-08-06T13:11:01Z",
          "updatedAt": "2019-08-06T13:11:01Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Additionally, replying to Med's comments (which I will put into an e-mail once I'm through):\r\n\r\nOn \"Host\":\r\n[Med19]: I personally prefer the definition in RFC1122 [\"Host: ultimate consumer of communication services. A host generally executes application programs on behalf of user(s), employing network and/or Internet communication services in support of this function.\"]\r\nThanks for the suggestion, I really like this definition as well. The distinction based on \"processes packets that are addressed/not addressed to [a node]\" has its problems, as this does not say on which layer we consider the addresses, this gets more complicated with encapsulation, etc. So I'm in favor of changing our definition of a host to something along the lines of RFC 1122.\r\n[Med20]: This is about receiving. You may also cover sending\r\nWe intend \"processes packets\" to include both sending and receiving, but I suggest we switch to a different definition as discussed above.\r\n\r\nOn \"Path element: Either a node or a link.\"\r\n[Med21]: This definition does cover, for example, the case of a path identified by an ordered list\r\nof AS Number. Check for example the definition of ERO in RFC3209, or even in recent documents\r\nsuch as RFC7570\r\nTrue. ERO can include groups of nodes, possibly this can mean entire ASes. We may want to allow \"aggregated\" path elements that are entire networks, captured by the network's AS number. Is it sufficient to express these as subpaths, e.g., consisting of all nodes and links within this AS? Maybe not, because we want this \"aggregated\" path element (group of nodes and links? cloud?) to be amorphous. As we may not have full visibility of all path elements in practice, most paths probably include at least one such \"aggregated\" path element anyway.\r\n\r\nOn \"Path: [\u2026] alternating between nodes and links\":\r\n[Med22]: This definition excludes recent notion such as SFP defined in RFC7665\r\nJust to make sure I got this right: Defining an individual Service Function (SF) or Service Function Chain (SFC) to be a node (which may be virtual) between which links may exist (either physical or virtual, maybe allowing virtual links to not just be between virtual network interfaces but even within a single host) does not solve the problem? And then the Service Function Path (SFP) can be a sequence of nodes and links? Do you think this is this necessarily just a sequence of nodes, no links, because we would have to stretch the definition of a virtual link too far, or is there a different reason?\r\nOn \"A path can be viewed as an abstraction on a specific layer, omitting lower layer path elements.\"\r\n[Med23]: Contradicts with the sentence about alternating nodes/links.\r\nWhy? If we define a path on, e.g., layer 3, we can treat the link between two layer 3 devices as a virtual link, so we abstract from all physical links and nodes on layer 2. Do you have an alternative proposal how to phrase this?\r\n\r\nOn \"Property: A trait of one or a sequence of path elements [\u2026]\"\r\n[Med24]: I\u2019d like to double check If the defining covers also the concept of SFC/SFP. The path will be built to accommodate a property (result of SFC).\r\nI think this depends on how we define the sequence of path elements, see above, to make sure we cover these concepts.\r\n\r\nOn \"Aggregated property: A collection of multiple values of a property into a single value, according to a function.\"\r\n[Med25]: Note this cannot be applied to all properties of a connectivity service.\r\nCorrect. For all properties of a connectivity service, you would need a set of all aggregated properties.\r\n\r\nOn \"Measured property: A property that is observed for a specific path element or path, e.g., using measurements.\"\r\n[Med26]: I prefer \u00ab Observed \u00bb rather that measured because properties may not only be about traffic performance metrics.\r\nTrue, we define lots of other properties for which we can observe a value. So we may change this.\r\n\r\nOn \"Estimated property: An approximate calculation [CROSSED: or judgment] of the value of a property.\" \r\n[Med27]: As above, this is too measurement-centric. This may not be applicable to all properties.\r\nThe intention of the \"or judgment\" is to express that this may not be a numeric and/or performance-related property. I understand \"estimate\" to be broader than numerical but rather to include \"an educated guess\". However, it seems to me like most words in this space imply numeric values. So I'm looking for the right word here - does \"An approximate calculation or assessment of a numeric or non-numeric value of a property\" work? Any other suggestions?",
          "createdAt": "2019-08-07T08:45:20Z",
          "updatedAt": "2019-08-07T08:45:20Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Replies regarding the comments:\r\n\r\nMed really wants us to avoid the \"alternating between nodes and links\":\r\n\"[Med] I disagree these are \"nonsensical paths\". Defining a path as a sequence of nodes/functions may be sufficient for an endhost. For example, a collaborative network may decide to announce a set of functions to an endhost; those functions can be invoked individually or in a sequence. The endhost may impose a \"path\" that is defined (from its local standpoint) as a singleton function or a loose path defined as an ordered list of functions. Also, a MIF device can define a path with reference to its local interfaces (without even caring about further hops upstream).\r\n\r\n[TE] Agreed - as long as it is possible to pass packets across the path, it's not \"nonsensical\". However, even if a node only has a partial view of the path, such as a set of functions or a reference to a local interface, there is still at least one other node (the remote endpoint) that the node most likely cares about. Then, if the node does not know or care about the path elements inbetween, we might want to model them as an \"aggregate\" path element or something like this.\"\r\n\r\nFurther, regarding service functions:\r\n\"[Med] as I mentioned above, a same path may be viewed differently by distinct nodes. An endhost, for example, does not have to manipulate the same path granularity as a router or a Service Function Forwarder (RFC7665). Also, defining a path as a sequence of nodes/links may not be sufficient in some case as the overall path must also invoke a set of functions that may be collocated within a given node. \r\n\r\n[TE] But functions can also be nodes, right, and then a sequence of functions (nodes) can be located within a host (also a node)... I'm wondering if this will get confusing.\"\r\n\r\nRegarding views of the path:\r\n\"[Med] In short, a path can be zoomed in/out as a function of the context. \r\n\r\n[TE] I think what you call \"zoom in/out\" is similar to what we say in our current path definition, e.g., \"If [a] router does not implement transport layer functionality, it is hidden when a higher layer, such as the transport or application layer, is considered.\" - a host might not have to care about every individual router on the path. We'll see if we can make this clearer and/or more explicit.\"\r\n\r\nRegarding strict/loose paths:\r\n\"[Med] Moreover, a path does not need to be strictly defined; loose mode should also be supported.\r\n\r\n[TE] What is the difference between strict and loose here - full view\r\nvs. partial view of the physical topology?\"\r\n\r\nRegarding defining paths between two hosts/nodes: (comment from abstract, but I think we should also keep this in mind for our definitions)\r\n\"[Med] This will depend on the nature of a communication. I'm not sure this will apply for SSM, ASM or when anycast is used.\r\n\r\n[TE] Neither am I. I'll think about this more.\"\r\n\r\nTo [Med19] and [Med20], he agrees with my points.\r\n\r\nTo [Med23]:\r\n\"[Med] I would simply remove that sentence as I don't see how (assuming it is true) it can be useful. \r\n\r\n[TE] Perhaps this is related to our discussion about views of the path. We'll think about this more.\"\r\n\r\nTo [Med26] he says \"OK\".\r\n\r\nTo [Med27]:\r\n\"[Med] \"approximate assessment\" would be OK.\"",
          "createdAt": "2019-09-30T18:04:29Z",
          "updatedAt": "2019-09-30T18:04:29Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed via #21 ",
          "createdAt": "2019-11-04T10:49:57Z",
          "updatedAt": "2019-11-04T10:49:57Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "MDU6SXNzdWU0MTA3MjMwMzM=",
      "title": "Motivate why we pick these properties",
      "url": "https://github.com/panrg/path-properties/issues/2",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The draft should motivate why we choose these particular properties and not others.\r\n\r\nIs it because we want to do \"better than random\" prediction? Or are we just trying to get an idea of the state of a path?",
      "createdAt": "2019-02-15T11:20:03Z",
      "updatedAt": "2019-03-11T18:10:09Z",
      "closedAt": "2019-03-11T18:10:09Z",
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "Even though this is not part of our question (vocabulary of path properties), as question 3 & 5 will more closely look at what the actual use cases, I think we should nonetheless mention possible protocols that would benefit from path properties in order to justify our selection of path properties.\r\nThen we can argue about useful metrics for the majority of these protocols (e.g., delay, loss, bw, ...)\r\nIs this a good approach to motivate our selection?\r\n\r\n\r\nWhich systems profit from path awareness (benefits are mostly performance-wise in these cases)?\r\n- Applications (e.g., P2P, HTTP, ALTO)\r\n- Transport protocols (e.g., UDP, TCP, QUIC, SCTP)\r\n- Routing protocols (e.g., BGP, RIP, IGRP, EIGRP, OSPF, IS-IS)\r\n- Data link & physical layer protocols (IEEE 802.11, ethernet)\r\n\r\nWhat are desirable metrics for these systems?\r\n- Wireless properties: You already wrote the relevant metrics in the other pull request ( #3 )\r\n- Dynamic Properties as used in IPPM: Delay in RFC 7679, loss in RFC 7680, RTT in RFC 2681\r\n- Structural properties as used in ALTO: Basic network location structure and preferences of network paths\r\n\r\nAs a side note, this was mentioned in the ALTO requirement document, RFC 5693, as their goal (the overall goal being a peer selection better than random): Increase application performance, reduce congestion, and decrease the overall amount of traffic across different networks",
          "createdAt": "2019-02-26T17:18:05Z",
          "updatedAt": "2019-02-26T17:18:05Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm hesitant about starting out by naming actual protocols and claiming that our properties will improve their performance in some way. I'm also not sure we need the \"What are desirable metrics\" part here already, shouldn't that be part of the drafts answering the other questions?\r\n\r\nAt least I think we want to start with abstract reasons why one might want these properties, and then name some examples.\r\nI mean, choosing between different paths is one motivation, but not the only one.\r\n\r\nSo one reason is that one might want to choose between different paths, for example in routing protocols, where path properties could help influence routing metrics, right? Or on different layers, they could help choose between Transport Layer endpoints or Application-Layer peers. Maybe here we can also state or reference the \"better than random\" goal.\r\nMaybe this motivation shouldn't be the first one we name though, otherwise we end up \"predicting the future\" again... ;)\r\n\r\nI think another reason we might want path properties is network monitoring, e.g., to make sure that we meet some QoS requirements. Before we can improve performance, we need to understand it, so I think this reason should come first.\r\n\r\nAnother reason might be compliance with some policies, e.g., having a specific device present on the path, or only routing traffic through specific networks.\r\n\r\nMaybe let's start with these, and if we come up with more, we can add them?",
          "createdAt": "2019-02-26T19:52:13Z",
          "updatedAt": "2019-02-26T19:52:13Z"
        },
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "I removed discussion about desirable metrics and focused on scenarios where path properties are useful.\r\n\r\nI created the pull request #6 which so far only consists of the abstract scenarios without any examples.\r\nIf you think the scenarios are fine this way, we can add examples.",
          "createdAt": "2019-03-06T13:44:36Z",
          "updatedAt": "2019-03-06T13:44:36Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed via #6.",
          "createdAt": "2019-03-11T18:10:09Z",
          "updatedAt": "2019-03-11T18:10:09Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWU0MTA3MjQyMDc=",
      "title": "Be clearer on physical layer properties",
      "url": "https://github.com/panrg/path-properties/issues/3",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "theri"
      ],
      "labels": [],
      "body": "With physical layer properties such as modulation rate:\r\nBe either more abstract (i.e., not talk about 802.11 but just in general) or more specific (i.e., add satellite network properties).\r\nThe notes are not really clear on this...",
      "createdAt": "2019-02-15T11:23:08Z",
      "updatedAt": "2019-03-04T19:01:10Z",
      "closedAt": "2019-03-04T19:01:10Z",
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "After listening to the recording again and reading the mentioned RFC 8175 (Dynamic Link Exchange Protocol, DLEP), I'm fairly certain that they wanted us to be more abstract.\r\nDLEP specifies a set of metrics that should apply to different physical and link layer protocols, i.e., to 802.11 and satellite links and others. They are specifically defined on a layer 2 domain, so for our path, I guess this would be the first hop.\r\nRFC 8175 does not specify HOW exactly those metrics are calculated, but what they mean and what format they have. \r\nThey have \"per destination\" metrics and \"per session\" (for all destinations). I guess for us, \"per destination\" is enough, because we probably want to specify these as properties for a single hop among our path. \r\n\r\nSo, some of their metrics that might be relevant input for our properties:\r\n\r\n- Maximum data rate (receive/transmit) - Section 13.12 and 13.13 - this is the theoretical maximum data rate, in bits per second, that can be achieved on this link (i.e., the first hop) for receiving or transmitting traffic\r\n- Current data rate (receive/transmit) - Section 13.14 and 13.15 - this is the rate at which the link is currently operating, in bits per second, for receiving or transmitting traffic\r\n- Latency - Section 13.16 - transmission delay on the link, in microseconds\r\n- Relative link quality (receive/transmit) - Section 13.18 and 13.19 - this indicates link stability, with 0 = least stable = metrics are likely to change a lot, and 100 = most stable = metrics are likely to stay stable\r\n- MTU - Section 13.20 - maximum size of an IP packet in Bytes that can be transmitted without fragmentation, including IP headers, but excluding lower-layer headers\r\n\r\nWhat we have right now in the draft is:\r\n- Wireless Signal strength: Power level of the wireless signal being received. Lower signal strength, relative to the same noise floor, is correlated with higher bit error rates and lower modulation rates.\r\n- Wireless Modulation Rate: Modulation bitrate of the wireless signal. The modulation rate determines how many bytes are transmitted within a symbol on the wireless channel. A high modulation rate leads to a higher possible bitrate, given sufficient signal strength.\r\n- Wireless Channel utilization: Percentage of time during which there is a transmission on the wireless medium. A high channel utilization indicates a congested wireless network.\r\n\r\nI guess because it says \"Wireless\", they took it to mean 802.11-specific, and I guess by \"modulation rate\" I meant the same as \"current data rate\" in RFC 8175.\r\n\r\nI'm wondering why Signal Strength is missing from RFC 8175, as this is something that exists for most relevant protocols I guess, but in itself, Signal Strength is not really useful. In the end, I guess it mostly influences the available data rate, so if we have this one covered...\r\n\r\nSo I guess we can **substitute our \"modulation rate\" by \"maximum data rate\" and \"current data rate\"**, and we can **drop \"Signal Strength\"**. \r\n**Maybe drop \"Utilization\" as well**, as this presumes a shared medium, which does not apply to all link layers, and I'm not sure how useful it is?\r\n\r\nAlso, I guess we should **make our definition of MTU more specific**, but I think our MTU should be defined end-to-end on the path, not just on the first hop.\r\n\r\nI'm not sure we need another Latency that only applies on the first hop. Let's see how we define our \"path latency\" in relation to the formal definition of a path that we come up with.\r\n\r\nAlso, relative link quality I'm not quite sure we need.\r\n\r\nAny opinions on this?\r\n\r\nI'm planning to prepare a Pull Request for this next week.",
          "createdAt": "2019-02-22T18:31:49Z",
          "updatedAt": "2019-02-22T18:31:49Z"
        },
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it makes sense to substitute modulation rate by maximum data rate & available data rate.\r\n\r\nSince the overall goal of this document is to list properties that are useful for protocols using information about paths (path awareness), we can probably drop signal strength as the properties it influences (available data rate & loss rate) are what is mostly relevant.\r\n\r\nDropping Utilization is fine for me, since we have available & maximum data rate which together can be used to approximate Utilization.\r\n\r\nI also think an end-to-end MTU is more useful than a single-hop MTU.",
          "createdAt": "2019-02-26T10:28:28Z",
          "updatedAt": "2019-02-26T10:28:28Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed via #4 ",
          "createdAt": "2019-03-04T19:01:10Z",
          "updatedAt": "2019-03-04T19:01:10Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWU0MTc4NjkwNTA=",
      "title": "Formalize definitions of path properties",
      "url": "https://github.com/panrg/path-properties/issues/7",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "theri"
      ],
      "labels": [],
      "body": "With path and path element being defined more formally, we should revisit our path properties and perhaps define (some of) them more formally.\r\n\r\nI'd like to give this a try and put together a PR sometime this week.",
      "createdAt": "2019-03-06T15:37:57Z",
      "updatedAt": "2019-03-11T18:09:55Z",
      "closedAt": "2019-03-11T18:09:54Z",
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed via #8.",
          "createdAt": "2019-03-11T18:09:54Z",
          "updatedAt": "2019-03-11T18:09:54Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "MDU6SXNzdWU0Nzc3MjU2MjQ=",
      "title": "Abstract / scope",
      "url": "https://github.com/panrg/path-properties/issues/13",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "theri"
      ],
      "labels": [],
      "body": "Comments on the abstract:\r\n\r\n[Med1]:\r\n\"[Internet paths] assumes a global connectivity. I don\u2019t think this restriction is justified (consider enterprise networks, mesh networks, etc.).\"\r\nI agree - perhaps change \"Internet paths\" to \"paths across a network\"?\r\n\r\n[Med2]:\r\n\"Instead of reasoning about paths, what actually matters is the connectivity service(s) provided via an upstream network.\"\r\nWell, this is the Path-Aware Networking Research Group, so it makes sense to reason about paths, right? Yes, as an endpoint you actually care about what services your path provides, but I'm not sure I want to change any text based on this comment.\r\nMaybe add \"[information \u2026 that an entity \u2026 might have or want to have] about a path and the services it provides\"?\r\n\r\n[Med3]:\r\n\"A host will have a partial visibility of the available path(s) (and their associated services). The full visibility cannot be established beforehand. Furthermore, such information is volatile (e.g., handover or multi-attachment with session continuity).\"\r\nI agree, but I'm not sure I want to add text to the abstract based on this. I don't think we imply full visibility here if we talk about \"information\" that a host can get about paths. But we have to make sure this point is clear in the body of the text.\r\n\r\n[Med4]:\r\n\"GENERAL: the properties are dependent of the direction. Some properties will apply for inbound, outbound, or both.\"\r\nI agree, and I think our (planned) definition accounts for this: Links are unidirectional, the reverse direction is another unidirectional link between the same nodes, and a property applies on a sequence of path elements.\r\n\r\n[Med5]:\r\n\"[Between two hosts] excludes point-to-multipoint communications. Consider the case of an STB which want to retrieve TV channels using multicast.\"\r\nRight now, we define path as between two hosts (will perhaps change to \"between two nodes\" to include, e.g., overlays, but of course the two nodes can be hosts), and then point-to-multipoint can be expressed as a set of multiple paths, one for each pair of sender and receiver. Then, the same property can apply to multiple paths and, thus, be essentially the point-to-multipoint communication.\r\nAbout the text of the abstract, perhaps changing this to \"[properties of paths] between two or more nodes\" helps?",
      "createdAt": "2019-08-07T06:09:32Z",
      "updatedAt": "2019-10-24T13:26:57Z",
      "closedAt": "2019-10-24T13:26:57Z",
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Based on the replies from Med, apparently he agrees with most of the proposed changes, so we can use them as a starting point for the next version -- if that's okay with you, Cyrill, obviously :)\r\n\r\nI'm pushing back on one comment:\r\n[Med2] - \"IMO, an endhost does not care about a path per se, but about the service it will get when path(s) is/are used to forwarded its packets. Picking a path or any other decision about how to make use of available ones is an outcome of the intended connectivity service. [\u2026] This [suggestion to add] is better. I suggest: s/about a path and the services it provides/about services provided via a path\"\r\n--> While I agree that services are important, I do think that some nodes care about the physical path itself and not just the services. Therefore, I'd like to go with \"[information \u2026 that an entity \u2026 might have or want to have] about a path and the services provided via a path\".",
          "createdAt": "2019-09-25T14:27:31Z",
          "updatedAt": "2019-09-25T14:27:31Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "MDU6SXNzdWU0Nzc3NDEyNDQ=",
      "title": "Med comments on Introduction",
      "url": "https://github.com/panrg/path-properties/issues/14",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "theri"
      ],
      "labels": [],
      "body": "Replying to Med's comments on the Introduction:\r\n\r\nOn \"Because the current Internet provides an IP-based best-effort bit\r\npipe, hosts have little information about paths to other hosts.\":\r\n[Med6]: What is the causality effect here?\r\nI think here we intend to say that, in the current Internet, the path and its services are transparent to hosts, so hosts only know something is reachable, but they do not get all the details of via which networks, they do not necessarily get details on the services (e.g., QoS).\r\nDo you have a proposal of what text to change here?\r\n\r\nOn \"A Path Aware Network exposes information about one or multiple paths\r\nthrough the network\":\r\n[Med7]: I do still believe this is a weird term: networking is about manipulating paths, by essence!\r\nWell, hosts do not usually directly manipulate paths, unless they do source routing, right? Anyway, the term \"Path Aware Network\" is taken from the questions draft, which is an adopted Research Group document, so I wouldn't change it and introduce even more terms in the process.\r\n[Med8]: Difficult to parse\r\nWill see how we can rephrase this.\r\n\r\nCrossed out: \"[It is impossible to provide an exhaustive list of path properties], as with every new technology and protocol, novel properties might become relevant\"\r\nIs the comment here that the crossed out part does this not work as an explanation of the first part of the sentence? Why not?\r\n\r\nOn \"[Traffic policies: \u2026 Such policies can allow or disallow sending traffic over specific\r\nnetworks or nodes\":\r\n[Med9]: This is about path selection covered in the 3rd bullet.\r\nTrue, this can be a case of path selection - or you may find out that your policy does not allow you to send your traffic at all. The latter case is not covered by our current definition of path selection, so I think mentioning it here makes sense. But we should rephrase this sentence to make it more clear. Any suggestion?\r\n\r\nOn \"[select a protocol depending on the capabilities of the] on-path devices\":\r\n[Med10]: I agree with this example, but I have the following comments: The selection of the protocol is not only specific to on-path devices, but it can be the other way around: It is the selection of the protocol which may infer the devices that will be involved in a path. Consider the example of the 0-RTT Convert Protocol which is involved in a path only when invoked by a host; such invocation will lead to the use of MPTCP or TCPinc while this Is not doable with the default path. Another example of traffic policies is a connection which may be composed of\r\nmultiple streams, each stream with specific requirements. A host may decide to invoke a given service function (e.g., transcoding) only for some streams while others are not processed by that service function.\r\nTrue, there can be more complex interactions. Do you have a suggestion of what text to add here?\r\n\r\nOn \"the monetary cost [of the link]\":\r\n[Med11]: This is linked to a network, not a path.\r\nYes, this usually applies to only a part of the path, e.g., a specific network. However, from the point of view of a host, which sees the path containing this network, it may be a property of the path. Perhaps we should change the sentence here to \"the monetary cost to send data across a network on the path\" to make the example clearer.\r\n\r\nOn \"Another example is an enterprise network where all traffic has to go through a firewall, in which case the host needs to be aware of on-path firewalls.\"\r\n[Med12]: How this information is useful for enforcing \u201ctraffic policies\u201d discussed in this bullet? What would be interesting is to have means to control such firewalls.\r\nThe idea here was that a host may have a policy to have all its traffic filtered through a specific firewall, so if the firewall is not available for some reason, it will not sends its traffic, or it will send different traffic, e.g., encapsulate it using a VPN. Does this example make sense to you?\r\nAgree that controlling firewalls from the host could be another interesting use case, but I'm not sure if this is in scope of this draft. After all, our model is that the host gets information about the path, not that it manipulates the path.\r\n\r\nOn \"Network monitoring: Network operators can use path properties (e.g., measured by on-path devices), to observe Quality of Service (QoS) characteristics of recent end-user traffic, and identify potential problems with their network early on, before the end-user complains.\"\r\n[Med13]: Which information is exposed here?\r\nThe idea here is to expose performance characteristics, such as latency or packet loss, to nodes on the same subpath, so the performance problem can be mitigated. Think LOOPS overlay nodes which might detect an increase in packet loss and, as a result, retransmit packets or add FEC. Perhaps \"monitoring\" is not the right term here, because this scenario also involves mitigation - maybe \"Performance enhancement\" is a better term here?\r\n\r\nOn \"[a non-dynamic path property might stay relevant, e.g. a NAT can be assumed to stay on a path during the lifetime of a connection, as the removal of] the NAT would break the connection.\"\r\n[Med14]: Not for MPTCP/QUIC.\r\nYou're right, this was written with single-path TCP in mind.\r\nPerhaps change this to \"a non-dynamic path property might stay relevant for a longer period of time, e.g. a NAT typically stays on a specific path during the lifetime of a connection involving packets sent over this path\" - this leaves it open whether NAT rebinding occurs and whether additional packets of the same connection are sent over different paths. I think the only case in which the \"typically\" does not apply here is if the NAT were to be removed from the specific path, e.g., the NAT functionality of the router switched off. And this I find unlikely to occur during most connections.\r\n\r\nOn \"Non-dynamic properties are further separated into (local) domain properties related to the first few hops of the connection, and backbone properties related to the remaining hops. Domain properties expose a high amount of information to hosts and strongly influence the connection behavior while there is little influence and information about backbone properties.\" \r\n[Med15]: Advanced service (e.g., NAT, IDS, ..) may be located in a Centralized PoP or hosted by a third party (DDoS protection, for example). Do you consider these as domain properties?\r\nIn our current definition, they would not be domain properties.\r\n[Med16], on \"Domain properties expose a high amount of information to hosts\": Why?\r\nThe assumption here is that from nearby path elements, you may be more likely to get performance information, such as Channel utilization and such from QBSS information elements sent by a WiFi access point, or that you are more likely to know about and explicitly configure an HTTP proxy within your own administrative domain.\r\n[Med17], on \"strongly influence the connection behavior\": ?\r\nThe assumption here is that, for example, performance may be more strongly influenced by the access network because it includes the bottleneck or a proxy. This doesn't always hold though, and perhaps we need to revisit our assumptions.\r\n[Med18]: You may need to call out your topology assumptions because some conclusions may not apply to some topologies.\r\nAgreed, and I think this leads us to a more general discussion about the scope of the draft.",
      "createdAt": "2019-08-07T06:57:26Z",
      "updatedAt": "2019-10-30T16:16:15Z",
      "closedAt": "2019-10-30T16:16:15Z",
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "In the introduction, we might want to add some context on the architecture we're thinking about, as raised by Med's comments. In reply, I wrote:\r\nWhile it sounds to me like a full-fledged reference architecture for Path-Aware Networking could be another draft, indeed it might make sense to give more context, perhaps in the Introduction of our draft. We'll consider doing this for the next revision and I'll be happy to discuss this more afterwards.\r\n\r\nTo [Med6], he suggested the following:\r\n\"==\r\nOLD: \r\n\r\nBecause the current Internet provides an IP-based best-effort bit\r\n   pipe, hosts have little information about paths to other hosts\r\n\r\nNEW:\r\nIn general, hosts do not have information about underlying forwarding paths and associated services. \r\n\r\n\r\nThere are some architectures that are deployed which provide assistance to hosts with some path policies/information, e.g., Access Network Discovery and Selection Function (ANDSF).\"\r\n\r\n\r\nTo the crossed out part:\r\n\"This is trivial; you don't even need to justify yet.\"\r\n\r\nTo [Med9]:\r\n\"I would move it under path selection and clarify that path selection is fed with policies (e.g., trafic policies).\"\r\n\r\nTo [Med10] he suggested the following text:\r\n\"NEW:\r\n    The selection of a protocol may infer the devices that will be involved in a path. For example, a 0-RTT Transport Converter [I-D.ietf-tcpm-converter] will be involved in a path only when invoked by a host; such invocation will lead to the use of MPTCP or TCPinc capabilities while such use is not supported via the default forwarding path. Another example of traffic policies is a connection which may be composed of multiple streams; each stream with specific service requirements. A host may decide to invoke a given service function (e.g., transcoding) only for some streams while others are not processed by that service function.\"\r\n\r\nTo [Med11], he suggested:\r\n\"the monetary cost to send data across a network, eventually on a given path\" \r\nI don't understand why \"eventually\", so I asked.\r\n\r\nTo [Med12], he suggested:\r\n\"OLD: \r\n     Another example is an\r\n      enterprise network where all traffic has to go through a firewall,\r\n      in which case the host needs to be aware of on-path firewalls\r\n\r\nNEW: \r\n     Another example is an\r\n      enterprise network where all traffic has to go through a specific firewall,\r\n      in which case the host needs to be aware of paths involving that firewall.\"\r\n\r\nWe also had a brief discussion that the host may be able to manipulate the path, see https://tools.ietf.org/html/draft-bernardos-sfc-discovery-03\r\n\r\nTo [Med13]:\r\n\" That is better. The explanation about subpaths is useful because I was looking for the role of an endhost. Having a figure would be helpful for this one.\"\r\n\r\nTo [Med14] he agrees with my points\r\n\r\nTo [Med16]:\r\n\"I'm not sure there is a rule there. You may be in a local network but the administrator restricts the amount of information you may have access ti from within that local network, but you can connect to a cloud and select the appliances you want to invoke. \r\n\r\nI would just remove such statement. \"\r\n\r\nTo [Med17] and [Med18] he agrees with my points.\r\n\r\nI said we'd consider his suggestions, but I didn't promise anything further and I didn't mean to make any decisions by myself - so, Cyrill, feel free to disagree with what I'm writing here!",
          "createdAt": "2019-09-30T17:55:11Z",
          "updatedAt": "2019-09-30T17:55:55Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "MDU6SXNzdWU0Nzc4MTM3MzY=",
      "title": "Med comments on Domain properties",
      "url": "https://github.com/panrg/path-properties/issues/15",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "theri"
      ],
      "labels": [],
      "body": "On \"3. Domain properties\":\r\n[Med28]: I\u2019m afraid this section (and section 4) implies architectural considerations which may not be appropriate in a terminology document.\r\nAs the scope of this document is to answer the first question of the Questions draft (Section 2.1 in draft-irtf-panrg-questions), \"how are path properties defined and represented?\", yes, this is a terminology document, but I wonder if possible classification of path properties is in scope. Here, our intention was to introduce such classification (e.g., dynamic and non-dynamic) to make it easier to reason about different properties, their usefulness, etc. However, I'm not sure if the classification into \"domain\" and \"backbone\" properties is indeed the right way to go. In the draft we give a number of reasons why it may matter if a path element is in the same administrative domain as a host or not. I'm sure there's a number of considerations here that may already touch upon other questions of the Questions draft, e.g., the second question of Discoverability, Distribution, and Trustworthiness of path property. However, the second question already asks how an endpoint can get access to trustworthy path properties, which we do not attempt to answer in this draft. So I'm not sure what the right trade-off here is between focusing the document on terminology and definitions vs. discussing considerations of where path elements may be located and who may control them. I'm very interested to get guidance from the Research Group here.\r\n\r\nOn \"the first few hops\":\r\n[Med29]: 2, 10 ?\r\nWe kept this intentionally vague to cover both cases in we really consider only the first hop and cases in which we consider the entire access network behind that hop as well. I think deciding whether we want a clear definition here depends resolving the issue raised by the comment [Med28] above.\r\n\r\nOn \"the same administrative domain as a host considering them.\"\r\n[Med30]: L2, L3, ?\r\nPersonally I mostly think about domains in this document as everything covered by the same AS, but yes, it would be very interesting to come up with a clear definition of domain here.\r\nFor example, PCE defines a domain as a \"collection of network elements within a common sphere of address management or path computation responsibility, can be IGP areas, ASes, multiple ASes within a Service provider network. may also exist as sub-domains of areas or ASes.\". PANRG is more broad, but maybe we can come up with something similar here?\r\nAgain, I think deciding whether we want a clear definition here depends resolving the issue raised by the comment [Med28] above.\r\n\r\n[Med31]: This would exclude then a host connected to a UE connected to a PLMN or a CPE connected to an enterprise or provider networks. These elements do not belong to the same\r\nadministrative entity.\r\nIn my understanding, an element belonging to an administrative domain does not necessarily mean that the element belongs to the entity which owns the domain. For example, if my phone (the UE) connects to a cellular network (the PLMN), the mobile phone still belongs to me. However, the phone might also be a host on a path through this cellular network. In this case, I intend the definition to have the phone, the base station, and the cellular infrastructure behind the base station all belong to the same administrative domain, as for example all L3 devices here get assigned IP addresses from a common address space that belongs to the provider of the cellular network. If my phone leaves the cellular network, it does not keep the IP address, then it's no longer part of that administrative domain. Can we come up with a more general definition of a domain that does not rely only on IP address space?\r\nAgain, I think deciding whether we want a clear definition here depends resolving the issue raised by the comment [Med28] above.\r\n\r\nOn \"Due to the potential physical proximity and pre-existing trust or contractual relationships between hosts and path elements within the same domain, domain properties may be more accessible to the host than other properties.\"\r\n[Med32]: Which contractual relationships would apply to this case?\r\nFor example, if my host connects to a service provider's network, I may be a customer of this service provider, e.g., through my DSL subscription. This MIGHT mean that the provider is more willing to or has to give me (or my host) more information, e.g., about network performance characteristics.\r\nPhysical proximity is easier, I think: A WiFi AP may send out information of its currently observed channel utilization within QBSS information elements. A host only gets this information because it's directly connected to the AP, which implies physical proximity. \r\nAgain, such considerations already touch upon the second question of the Questions draft.\r\n[Med33], on the same text: I\u2019m not sure about this.\r\nThis may not always be the case, naturally. We just thought it might be helpful to state that it might be the case to motivate our classification into domain and backbone properties.\r\nAgain, this depends on [Med28] resolution.\r\n\r\nOn \"hosts may be able to influence [\u2026] which domain they are in\"\r\n[Med34]: Connecting to a domain does not mean that the host belongs to that domain.\r\nThen this is a wording issue and we should change something in our definition to \"connect to a domain\" or \"be in a domain\" instead of \"belong to a domain\".\r\nHowever, again, this depends on [Med28] resolution.\r\n\r\nOn \"they may be able to influence the properties of path elements within this domain.\"\r\n[Med35]: An example ?\r\nGiven in the rest of the paragraph: \"when connected to an Access Point, the user may move\r\ncloser to enable their device to use a different access technology, potentially increasing the data rate available to the device.\"\r\n[Med36]: How a host can influence the one-way delay provided by a network?\r\nProbably not. We never suggest that a host can influence ALL properties.\r\n\r\nOn \"Access Technology: The physical or link layer technology used for transmitting or receiving a flow on one or multiple path elements in the same domain. The Access Technology may be given in an abstract way, e.g., as a Wi-Fi, Wired Ethernet, or Cellular link. It may also be given as a specific technology, e.g., as a 2G, 3G, 4G, or 5G cellular link, or an 802.11a, b, g, n, or ac WiFi link. Other path elements relevant to the access technology may include on-path devices, such as elements of a cellular backbone network. Note that there is no common registry of possible values for this property.\" \r\n[Med37]: This is basically in a domain != from the local network\r\nWhy not in the local network? I think this specifically applies to many local networks, where it's actually interesting if, e.g., a WiFi AP supports 802.11ac or not. Perhaps I'm misunderstanding something your comment, could you clarify, please?\r\n\r\nOn \"[Monetary Cost: The price to be paid to transmit a specific flow across a] subpath.\"\r\n[Med38]: A network\r\nRight now, in the context of a path, all path elements within the network form a subpath. So this applies to the subpath. However, if we extend our terminology to include aggregated/abstract path elements, maybe we can have an abstract path element that represents a network.",
      "createdAt": "2019-08-07T09:31:24Z",
      "updatedAt": "2019-11-04T10:50:18Z",
      "closedAt": "2019-11-04T10:50:18Z",
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Replies from e-mails:\r\n\r\nTo [Med30]: \"Noted\" - so yes, let's see if we can come up with a good definition of domain, or if we want to get rid of the distinction. What do you think, Cyrill?\r\n\r\nTo [Med31]: \r\n\"> [Med] even at L3, that host does not belong to same domain. \r\n\r\n[TE] I guess whether a specific path element belongs to a specific domain depends on the exact definition of domain. If it's defined by \"who owns the address space on L3\", I don't see why it wouldn't belong to that domain.\"\r\n\r\nAlso:\r\n\"[Med] May be, but my main concern (still) is whether there is a need to define domain/backbone.\"\r\n\r\nSo, I guess these comments are related to the exact definition of domain and on the question whether we keep this concept in our draft or get rid of the distinction.\r\n\r\nTo [Med32]:\r\n\"[Med] I was concerned about \"relationships between hosts and path elements within the ** same domain **\". Contracts are usually between elements that do not belong to the same domain.  \r\n\r\n[TE] That's for a different definition of domain. But yes, contracts may exist with different entities along the path, so we'll rethink this along with the definition and notion of domain.\"\r\n\r\nTo [Med37]:\r\n\"> [Med] I think the disconnect is the terminology but also the architectural assumptions. Usually, access technology is used between a device an access network with distinct administrative boundaries.\r\n\r\n[TE] Yes, it's often the first link between a device and the node which is the first hop, such as an access point or base station. Does it help if we just remove \"in the same domain\" or change it to \"in the local\" network or something similar? Because I think we can define this regardless of the larger \"domain\" issue.\"",
          "createdAt": "2019-09-30T18:09:10Z",
          "updatedAt": "2019-09-30T18:09:10Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed via #22 ",
          "createdAt": "2019-11-04T10:50:18Z",
          "updatedAt": "2019-11-04T10:50:18Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "MDU6SXNzdWU0Nzc4MjQxMTU=",
      "title": "Med comments on Backbone properties",
      "url": "https://github.com/panrg/path-properties/issues/16",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "On \"Typically, backbone properties are less accessible to a host than domain properties, due to the potential increased distance and the lack of pre-existing trust or contractual relationship.\"\r\n[Med39]: Not sure about this.\r\nNot sure if \"typically\" is the right word here either, but, similar to the part with [Med33], the intention is to say that this might be the case.\r\n\r\nOn \"hosts are less likely to be able to influence which path elements form their path in the backbone, as well as their properties.\"\r\n[Med40]: This may contradict with slicing use cases.\r\nSounds interesting. Could you point me to a specific reference, please?\r\n\r\nOn \"Presence of a certain [CROSSED: network] service function on the path\":\r\n[Med41]: To be aligned with RFC7665\r\nAgreed.\r\n\r\nOn \"Administrative Entity: The administrative entity, e.g., the AS, to which a path element or subpath belongs.\"\r\n[Med42]: This is an administrative domain, not * entity *\r\nIsn't an AS also an entity? But yes, maybe we could have the administrative domain be a property instead?\r\n\r\nOn \"Disjointness\":\r\n[Med43]: you may also refer to the PCE RFCs which defines also the notion of near disjointness\r\nI found RFC 4655 saying \"The path computation request may include a significant set of requirements, including the following: [\u2026] the number of disjoint paths required and whether near-disjoint paths are acceptable\", but it does not define what near-disjoint is. Is there a specific degree of disjointness that is generally still considered \"near\"? Anyways, I think if a host or other entity knows about the degree of disjointness, it can decide whether this is \"disjoint\" enough. Maybe we want to add a reference to PCE as an example use case.",
      "createdAt": "2019-08-07T09:51:10Z",
      "updatedAt": "2019-11-04T10:50:27Z",
      "closedAt": "2019-11-04T10:50:27Z",
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Replies to the e-mails:\r\n\r\nTo [Med39]:\r\n\"[Med] OK, but still don't see the need to have such assertion included. \"\r\n\r\nTo [Med42]:\r\n\"[Med] The administrative entity is the network operator of that AS. \r\n\r\n[TE] Right. We may need a different word here.\"\r\n\r\nThen my suggestion:\r\n\"[TE] But yes, maybe we could have the administrative domain be a property instead?\r\n\r\n[Med] That would make sense. For example, an application can decide to select a path that does not cross a given AS or better, an application can indicate a hint to an upstream network to avoid forwarding data via paths including a given AS.\r\n\r\n[TE] Yes, that's the primary use case we had in mind, so we'll make sure it's supported.\"\r\n\r\nHe also linked to some other type of domains (?):\r\n\r\n\"The same considerations would apply for application-specific domains such as ITADs (IP telephony administrative domains, https://www.iana.org/assignments/trip-parameters/trip-parameters.xml#trip-parameters-5). \"",
          "createdAt": "2019-09-30T18:11:29Z",
          "updatedAt": "2019-09-30T18:13:47Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed via #22 ",
          "createdAt": "2019-11-04T10:50:27Z",
          "updatedAt": "2019-11-04T10:50:27Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "MDU6SXNzdWU0Nzc4MjUwNDk=",
      "title": "Med comment on Dynamic Properties",
      "url": "https://github.com/panrg/path-properties/issues/17",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Last one...\r\n\r\nOn \"Latency\", \"Latency variation\", \"Packet loss\":\r\n[Med44]: Please use conventional terms : one-way delay, one-way delay variation, one-way loss, etc.\r\nYes, it might be useful to use terms as defined, e.g., in IPPM, and add references here.",
      "createdAt": "2019-08-07T09:52:57Z",
      "updatedAt": "2019-10-23T15:10:19Z",
      "closedAt": "2019-10-23T15:10:19Z",
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "I guess there are two ways for doing this:\r\n- Use the same terms as IPPM and always add a disclaimer that the terms are not exactly equivalent (e.g., different path definition, not only IP traffic)\r\n- Keep existing names and add reference to IPPM drafts\r\n\r\nI like the first option more as it keeps the terminology as consistent as possible, we just need to make sure to clearly state the difference to IPPM.\r\n\r\nI also made slight adjustments to the descriptions:\r\n- link capacity (no longer defined on subpath and path; we can use aggregated properties for that)\r\n- one-way delay variation: added difference between IPPM and us (variation on packets on the same flow instead of packets with same src/dst IP address)\r\n- packet loss: added reference for loss pattern and loss periode\r\n\r\nCommit: 15a84c4abca9ebfa44eb625763d66cd450bdcc1c\r\n\r\nWhat do you think?",
          "createdAt": "2019-10-11T11:15:00Z",
          "updatedAt": "2019-10-11T11:15:00Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for this!\r\nI like the first option as well, as these terms seem more clear to me than the ones we had.\r\n\r\nSo, please merge that branch and then close this issue. Thanks! :)\r\n\r\nBy the way, I'll try to make progress on the terminology and the other stuff this week.",
          "createdAt": "2019-10-21T07:04:49Z",
          "updatedAt": "2019-10-21T07:04:49Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "MDU6SXNzdWU1MzM0NzA5ODk=",
      "title": "Include editorial changes and some new definitions based on Med's review of -03",
      "url": "https://github.com/panrg/path-properties/issues/23",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "theri"
      ],
      "labels": [],
      "body": "Include some of the changes in https://github.com/boucadair/IETF-Drafts-Reviews/blob/master/draft-enghardt-panrg-path-properties-03-rev%20Med.pdf\r\n\r\nIn the following places we may change the suggested inputs from the review:\r\n\r\nIn the \"Node\" definition, we would like to highlight that a node can be physical or virtual, so we decided we wanted to give examples for both - so we'll put in \"e.g., a physical machine or a service function\" (and not virtual machine), because the service function is an example for a virtual node, so we'll have the machine be a physical one.\r\n\r\nTowards the end of the \"Path\" definition, there's a sentence on path visibility. We would like to make sure that the visibility aspect is clear in our definitions, but we are not sure yet whether adding this particular sentence is the best way to do it, as we already have a sentence on visibility right before. We'll consider how to phrase and possibly consolidate our definition in the next revision. \r\n\r\n(Not include the discovery part)\r\n\r\nThe definitions of Reverse path and Symmetric path seem useful to us as part of a base terminology for path properties, so we'll include them.\r\n\r\nThank you for the input on the \"Use cases\" section. We are going to revise this section based on input we got at IETF 106, and we will consider your feedback as well when doing so. As we revise our use cases section, we will consider whether to put any reference to them into the abstract or not.\r\n\r\nFor the definition of the \"Transport Protocols available\" property, again, we are not sure we want to go into detail about how to discover or cache this property, so we would opt for less detail here.",
      "createdAt": "2019-12-05T16:49:31Z",
      "updatedAt": "2020-03-18T02:59:07Z",
      "closedAt": "2020-03-18T02:59:07Z",
      "comments": []
    },
    {
      "number": 24,
      "id": "MDU6SXNzdWU1MzM0NzI3NDg=",
      "title": "Clarifications based on review by Luis M. Contreras",
      "url": "https://github.com/panrg/path-properties/issues/24",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "theri"
      ],
      "labels": [],
      "body": "On \"access technology\":\r\n\r\n\"As a path consists of a sequence of path elements, which can be nodes or\r\nlinks, our definitions do not enforce specifying an interface or\r\nsub-interface as part of the path.\r\n\r\nWe would like to make this clearer in the draft and we are wondering if the question comes from the choice of the term \"access technology\". We think what we actually mean here just the \"link type\" on the physical or link layer, no matter if in the access network or anywhere else on the path. Does renaming the property help? Or do you think the definition of the property has to be changed?\r\n\r\nOtherwise, maybe it would help to say explicitly that defining a property, such as \"link type\", does not mean that we require each entity to specify or know about this property. So, if an entity does not know about the link type or the exact interfaces involved in a path, that is not a problem, the entity can still express the path based on all path elements it knows or cares about.\r\n\r\nDoes this help?\"\r\n\r\nOn being flexible to include different levels of abstractions:\r\n\r\n\"Our intention is for the definitions to be flexible enough to accomodate both [a path can be simply equivalent to a route (i.e., a list of links) or something much more complex, including e.g. slots in FlexEth connections or ODUs in OTN, aggregated links in LAG configurations, etc.]\r\n\r\nFor example, using our current definitions it should be possible to express a complex path including slots in FlexEth connections, or aggregating multiple links (physical or virtual) to one virtual link.\r\n\r\nWe will consider how to make this clearer in the next revision.\"",
      "createdAt": "2019-12-05T16:52:34Z",
      "updatedAt": "2020-02-19T08:05:17Z",
      "closedAt": "2020-02-19T08:05:17Z",
      "comments": []
    },
    {
      "number": 25,
      "id": "MDU6SXNzdWU1NDg5NTg3OTc=",
      "title": "Definition of Transparency",
      "url": "https://github.com/panrg/path-properties/issues/25",
      "state": "CLOSED",
      "author": "cyrill-k",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cyrill-k"
      ],
      "labels": [],
      "body": "There were two comments during the presentation at IETF 106 that proposed adding a transparency property.\r\n\r\n> Joachim Fabini: I find it interesting to have a property of a layer X transparency, so we could have a property on a specific layer, if you're transparent for a given layer then you have an end-to-end conversation between the adjacent non-transparent nodes.\r\nTheresa: Could you find a reference for that and post it to the list, I'd like to take a list at how you mathematically express those.\r\nJoachim: For security, is there any property about security/encryption at a specific layer?\r\nTheresa: I could imagine talking about trust in some way, that's really complicated, I'm not sure you want to cover how much you trust a specific path element as a given property. You would always have to qualify it, and encryption is not the same as encryption.\r\nJoachim: Encryption could be done from end nodes to end nodes\r\nTheresa: I'm not sure I'm defining a threat model in there, though. The trust question is really interesting and we should revisit it\r\n\r\n> Mirja: Plus one on adding transparency or definition of transparency, but don't need to decide before adoption.\r\n\r\nWe changed the path definition in this revision by changing from \"hiding path elements on a higher layer\" to \"having partial visibility of the path elements\" in 4528e8db99aa3138b429d9b48e3f31b33478059a.\r\nI'm wondering if the desire for transparency comes from the fact that it is not clear enough that we can define a path on different layers using virtual nodes/links or if each property should define for which layers it is visible/transparent.\r\nThe former we could fix by rephrasing the path definition, but the latter would require extending the property definition.\r\n\r\nI'm not a big fan of extending the property definition since this would require us to also define layers which I'm not sure how to do (OSI, end-to-end vs not end-to-end, ...?)",
      "createdAt": "2020-01-13T14:16:13Z",
      "updatedAt": "2021-10-24T22:46:06Z",
      "closedAt": "2021-10-24T22:46:06Z",
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "> We changed the path definition in this revision by changing from \"hiding path elements on a higher layer\" to \"having partial visibility of the path elements\" in 4528e8d.\r\n\r\nFor me, our current definition of a path \"having partial visibility of the path elements [\u2026] and entities may treat path elements at different levels of abstraction\" is not really about layering, but more related to knowing what exact elements are on a path (e.g., specific routers) VS just knowing that there's some AS or otherwise amorphous \"abstract nodes\". I think this related to layering, but not really what these comments meant.\r\nI think we removed the layering part from our path definition to simplify the definition and because we didn't think it was well-defined and people hadn't indicated they wanted it.\r\nHowever, now this has changed...\r\n\r\n> I'm wondering if the desire for transparency comes from the fact that it is not clear enough that we can define a path on different layers using virtual nodes/links or if each property should define for which layers it is visible/transparent.\r\n\r\nI think this is not about the definition of a path on different layers, so we don't have to change the path definition. \r\nI also do not think this is a per-property thing, so we don't need to change the definition of a property.\r\nI think this is about, e.g., first defining/knowing about a path \"on a low layer\" (for example, all nodes that read the IP header and the links between these nodes), and then talk about path elements that do not look further into the packet such as the TCP header (= path elements that are layer 4 transparent) VS path elements that do look at the TCP header (= layer 4 not transparent). Or maybe path elements that modify the TCP header VS path elements that do not modify it. \r\n\r\nIn the session, I think the desire to define \"layer x transparency\" goes back to the initial comment that Tommy made: Can we express somehow that a node on the path allows me [the host] to make choices, participates in some measurement, enables path selection, etc? \r\nTommy proposed to have a definition for nodes which let the host do something like this VS nodes which do not. I said that maybe this should rather be another property, and that we already have a property for \"this node can do something specific to the packets\" (Service Function). Then, Brian said he does not want us to do node classification in this document (which I guess refers to Tommy's suggestion), but there's room to talk about classes of functions a node provides, and then he started talking about transparency on a specific layer. Here I agree with Brian that we should be careful not to try to define every possible Service Function that a path element might have, but be generic.\r\n\r\nAll in all, I think we should not change our definitions based on this.\r\nHowever, we should consider adding a property saying \"this node does or does not [look/modify a packet header/payload on a specific layer]\". Maybe call it \"transparency\", maybe call it something else. This could be similar to our Service Function property, \"this node provides a certain service function\", and then we give a few examples what this could be, but do not try to enumerate all possible functions.\r\n\r\nInstead of defining OSI layers, we could just talk about \"the IP-layer\" (which we already do in the property definitions based on IPPM), \"the transport layer\", and \"the application layer\", or we could simply talk about different protocols within a packet (an IP header, a TCP header, ...).\r\n\r\nThis all becomes much more complicated with encapsulation, but I'm not sure we have to make this our problem, but let the Research Group think about it. After all, this is a Research Group document now, so everyone's responsible. ;)",
          "createdAt": "2020-01-14T18:18:33Z",
          "updatedAt": "2020-01-14T18:18:33Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Further comments on transparency in the [June 2020 PANRG interim](https://datatracker.ietf.org/doc/minutes-interim-2020-panrg-01-202006031700/):\r\n\r\n        - Brian: [\u2026] Previous life worked on path transparency. Transperency might be\r\n        looking at headers without changing them and that can affect protocols.\r\n        There might be more shades of grey, at least three. Add some nuance.\r\n        (Cyril: blocking or not blocking) Yes, that as well. Other kinds of\r\n        behavior changes as well.\r\n\r\nSo let's add some nuance. Not sure about the specific content to add though.",
          "createdAt": "2020-08-15T17:34:36Z",
          "updatedAt": "2020-08-15T17:34:36Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Jake's review and my reply:\r\n\r\n> 3.\r\n> I had a slightly hard time with the Transparency example in Examples\r\n> of Path Properties:\r\n>\r\n>     Transparency:  A node is transparent with respect to a protocol\r\n>        header, payload, or both for a specific action if the node\r\n>        performs this action independently of the given\r\n>        (meta-)information.  Actions can for example be blocking packets\r\n>        or reading and modifying (other protocol) headers or payloads.  An\r\n>        IP router could be transparent for transport protocol headers such\r\n>        as TCP and UDP, in contrast to a NAT that actively modifies TCP\r\n>        and UDP header information.\r\n>\r\n> Is it correct to say that in this usage, Transparency is defined only in\r\n> relation to flow properties?\r\n\r\nTransparency is defined in relation to a particular flow. Not sure if it's necessarily \"in relation to flow properties\", as I wouldn't say that a protocol header itself is necessarily a flow property. But I guess the presence of a header, or of a header field,  could be a flow property. For example, we already have a \"Protocol Features available\" property for features like ECN, and now one could define the actual presence/usage of ECN as a flow property.\r\n\r\n> Is it correct that \"block all TCP Syn packets\" is transparent with\r\n> respect to IP but not with respect to TCP?  (Or does relying on the\r\n> protocol type already break that?  And if so, is that still transparent\r\n> with respect to the TCP payload?)\r\n\r\nI think our Transparency definition does not yet go into that level of detail, but answering questions like these will refine it.\r\n\r\nAs a first proposal, I would say that blocking packets is not transparent to any part of a flow, as it prevents the entire flow from actually traversing the path. Therefore, it wouldn't be transparent with respect to IP either.\r\n\r\nWould you agree with that?\r\n\r\nCyrill, do you have more thoughts on this, as you originally added the text for this Property?\r\n\r\n> Is it also correct that a NAT is\r\n> transparent with respect to payloads, but not transparent with respect\r\n> to IP, TCP, or UDP headers?\r\n\r\nGenerally, yes.\r\n\r\nWe refined the Transparency definition to include different \"degrees\" of transparency with respect to a specific action. For example, NAT may not be transparent with respect to reading IP and TCP or UDP headers, but it could be transparent with respect to modifying TCP/UDP headers if it does not change port numbers (which might not be common or a good example - but I'm sure there's several on-path nodes that may read headers, but not modify them).\r\n\r\nSo I guess a specific path element can be \"read-transparent\" with respect to some parts of a packet/flow, and \"modify-transparent\" with respect to other (fewer) parts of a packet/flow.\r\n\r\nDoes that make sense?\r\n\r\n> (If I got all that right, I feel like saying a few sharper examples\r\n> along these lines would help to clear it up better.  If not, I guess\r\n> I'm too confused to know what to suggest, and I think it needs\r\n> clarifying.)\r\n\r\nI agree that adding examples will be good.",
          "createdAt": "2021-06-22T20:42:50Z",
          "updatedAt": "2021-06-22T20:42:50Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment from Med and my reply:\r\n\r\n>\u202f[Med] FWIW, another common usage of \"transparent\" is when a network function is invoked without requiring any signaling from the endpoints (unlike explicit mode) and while its presence is not easily detected by the endpoints (e.g., transparent proxies).\r\n>\r\n> It would be useful if the overlap with the common usage is clarified/avoided. Thank you.\r\n\r\n\r\n[TE] RFC 2616 defines a transparent proxy as \"a proxy that does not modify the request or response beyond what is required for proxy authentication and identification.\" Is this the definition you'd use as well, or are you referring to a different definition?\r\n\r\nFor the RFC 2616 definition, I think our Transparency definition actually covers that - if the proxy neither blocks nor modifies the HTTP payload, it is transparent to these parts of the packet, but it does potentially modify other parts of the packet. Also, it most likely terminates the TCP connection, so it isn't transparent to any protocol that is lower in the stack than HTTP. Do you agree? Maybe this could be one clarifying example.\r\n\r\nBeyond the transparent proxy, I'm wondering if \"This node explicitly communicates with the endpoint\" is another type of (Non-)Transparency, next to \"block\", \"modify\", and \"read\". Explicit communication between node and endpoint perhaps already means that the node modifies packets, but it's a bit more high-level, talking about the semantics of the modification, and implies intention. Maybe it's a separate property. This might be useful to have, but maybe it's too difficult to accurately model. But maybe talking about implicit VS. explicit signalling can be helpful, possibly referring to RFC 8558? ",
          "createdAt": "2021-06-22T20:43:56Z",
          "updatedAt": "2021-06-22T20:43:56Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Further replies:\r\n\r\n> [TE] RFC 2616 defines a transparent proxy as \"a proxy that does not\r\n> modify the request or response beyond what is required for proxy\r\n> authentication and identification.\" Is this the definition you'd use\r\n> as\r\n> well, or are you referring to a different definition?\r\n\r\n[Med] I'm afraid that some functions that are \"traged\" as transparent in operational networks are doing more than that. For example, in mobile network there are functions that inject/strip headers (HTTP headers), TCP options, etc. \r\n\r\n>\r\n> For the RFC 2616 definition, I think our Transparency definition\r\n> actually covers that - if the proxy neither blocks nor modifies the\r\n> HTTP\r\n> payload, it is transparent to these parts of the packet, but it does\r\n> potentially modify other parts of the packet. Also, it most likely\r\n> terminates the TCP connection, so it isn't transparent to any\r\n> protocol\r\n\r\n[Med] I think we could reason in term of \"transparency to endpoints\" in general, not only to a protocol.  \r\n\r\n> that is lower in the stack than HTTP. Do you agree? Maybe this could\r\n> be\r\n> one clarifying example.\r\n\r\n[Med] This would be useful, indeed. \r\n\r\n>\r\n> Beyond the transparent proxy, I'm wondering if \"This node explicitly\r\n> communicates with the endpoint\" is another type of (Non-\r\n> )Transparency,\r\n> next to \"block\", \"modify\", and \"read\". Explicit communication between\r\n> node and endpoint perhaps already means\r\n\r\n[Med] This means that an endpoint accepts whatever \"service\" that will provided by the node that is explicitly added to the communicated path. This is mainly from the sender standpoint. An interesting feature that we may consider is to associate a remote peer on the \"consent\" process to involve an intermediate function. \r\n\r\n that the node modifies\r\n> packets,\r\n> but it's a bit more high-level, talking about the semantics of the\r\n> modification, and implies intention. Maybe it's a separate property.\r\n\r\n[Med] I agree this is a separate property that it is worth to capture in the I-D. \r\n\r\n> This might be useful to have, but maybe it's too difficult to\r\n> accurately\r\n> model.\r\n\r\n[Med] Not sure what you meant by \"model\".\r\n",
          "createdAt": "2021-06-22T20:45:22Z",
          "updatedAt": "2021-06-22T20:45:22Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "More replies:\r\n\r\n> [Med] I'm afraid that some functions that are \"traged\" as transparent in operational networks are doing more than that. For example, in mobile network there are functions that inject/strip headers (HTTP headers), TCP options, etc.\r\n\r\n[TE] I see, thanks for the clarification. Our draft's definition would surely not classify these as transparent with respect to HTTP or TCP, and I agree that it'll be good to clarify this overlap in terminology.\r\n\r\n\r\n>> For the RFC 2616 definition, I think our Transparency definition\r\n>> actually covers that - if the proxy neither blocks nor modifies the\r\n>> HTTP\r\n>> payload, it is transparent to these parts of the packet, but it does\r\n>> potentially modify other parts of the packet. Also, it most likely\r\n>> terminates the TCP connection, so it isn't transparent to any\r\n>> protocol\r\n> [Med] I think we could reason in term of \"transparency to endpoints\" in general, not only to a protocol.\r\n\r\n[TE] How would you define transparency to endpoints? There could be a distinction between whether an endpoint explicitly communicates with the on-path node (e.g., explicit signals as discussed in RFC 8558). Is this the same as the \"accepting a service that will be provided\" that you mention below?\r\n\r\n\r\n>> Beyond the transparent proxy, I'm wondering if \"This node explicitly\r\n>> communicates with the endpoint\" is another type of (Non-\r\n>> )Transparency,\r\n>> next to \"block\", \"modify\", and \"read\". Explicit communication between\r\n>> node and endpoint perhaps already means\r\n> [Med] This means that an endpoint accepts whatever \"service\" that will provided by the node that is explicitly added to the communicated path. This is mainly from the sender standpoint. An interesting feature that we may consider is to associate a remote peer on the \"consent\" process to involve an intermediate function.\r\n>\r\n>   that the node modifies\r\n>> packets,\r\n>> but it's a bit more high-level, talking about the semantics of the\r\n>> modification, and implies intention. Maybe it's a separate property.\r\n> [Med] I agree this is a separate property that it is worth to capture in the I-D.\r\n\r\n[TE] Yes, I we probably can't capture all nuances in the Path Properties draft.\r\n\r\n\r\n>> This might be useful to have, but maybe it's too difficult to\r\n>> accurately\r\n>> model.\r\n> [Med] Not sure what you meant by \"model\".\r\n\r\n[TE] Oh, this is basically the same point made above: Transparency can be difficult to define and I think a definition based on nodes that can send, receive, forward, or modify packets won't capture all nuances.\r\n",
          "createdAt": "2021-06-22T20:45:52Z",
          "updatedAt": "2021-06-22T20:45:52Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Final replies for this thread:\r\n\r\n> [TE] How would you define transparency to endpoints?\r\n\r\n[Med] This can be defined as adding an intermediate function to a communication without an explicit signal/consent from one of the endpoints.  \r\n\r\n> There could be a\r\n> distinction between whether an endpoint explicitly communicates with\r\n> the on-path node (e.g., explicit signals as discussed in RFC 8558).\r\n> Is this the same as the \"accepting a service that will be provided\"\r\n> that you mention below?\r\n\r\n[Med] Yes. \r\n",
          "createdAt": "2021-06-22T20:46:37Z",
          "updatedAt": "2021-06-22T20:46:37Z"
        },
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "I slightly changed the transparency definition such that (meta-)information includes the **existence** of a protocol (header).\r\nI added two examples relating to RFC2616 and RFC8558.\r\nI also added three examples of (non-)transparency to show the three different possibilities:\r\n- IP router: IP non-transparent and TCP/UDP transparent\r\n- SYN flood FW: IP transparent and TCP/UDP non-transparent\r\n- NAT: IP and TCP/UDP non-transparent\r\n\r\nI didn't add an additional property for \"endpoint transparency\" since I'm not sure we really need it at this point.\r\n\r\nWhat do you think? Do we need to fundamentally change the property definition or is the proposed change enough?",
          "createdAt": "2021-07-02T15:34:19Z",
          "updatedAt": "2021-07-02T15:34:19Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "At the IETF 111 PANRG session, there was a discussion around the transparency definition in the chat:\r\n\r\n> Cyrill: Hi Richard. Thanks for the interesting question/comment. A way\r\nwe could define the current property mathematically is: modelling a function f that takes as input the different (meta-)information metrics and the packet(s) and outputs the action taken, i.e., f(metrics, pkt). And then transparency would be f(metrics, p1) == f(metrics, p2) for all packets p1 and p2 that only differ in the metric.\r\n> Richard: This looks good as one possibility, implying constant. In your original doc (e.g., IP vs NAT example), it is the no-taint requirement, in that the function f does not access the metric. In PL/security, it is no taint.\r\n> It looks that the second one is more what you want.\r\n> Cyrill: What do you mean with PL/security?\r\n> Richard: programming language (PL). I mean the technique in that field.\r\n> Cyrill: Ok, thanks for the pointers. I will look it up to see how it could be applied in our definition.\r\n> Richard: Sounds good. I will be happy to chat later.\r\n> Cyrill: Thanks, that would be great.\r\n\r\nShould anything change in the transparency definition as a result of this discussion?",
          "createdAt": "2021-10-12T18:14:57Z",
          "updatedAt": "2021-10-12T18:14:57Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "MDU6SXNzdWU1NDk3MzkyNTE=",
      "title": "Look at ALTO path vector definition",
      "url": "https://github.com/panrg/path-properties/issues/26",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "theri"
      ],
      "labels": [],
      "body": "At IETF 106, Sabine Randriamasy mentioned ALTO and its \"path vector\" definition.\r\n\r\nWe should see if this is already in our wiki of Related Work. If not, we should add it.\r\nThen, we should consider whether there's anything in there we want to include or reference in our draft.\r\nI think Brian already summarized the distinction between our work and ALTO nicely: We talk about abstract categories, the IETF defines a concrete representation and wire encoding.",
      "createdAt": "2020-01-14T18:23:02Z",
      "updatedAt": "2020-09-04T21:47:34Z",
      "closedAt": "2020-09-04T21:47:34Z",
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "I read some ALTO RFCs and drafts and I added some of them to our [wiki page](https://github.com/theri/draft-enghardt-panrg-path-properties/wiki#application-layer-traffic-optimization-alto).\r\n\r\nIt seems to me like their definitions are compatible with ours. For example, an ALTO abstract network element could be an example of a node. Also, their performance cost metrics are basically path properties related to performance.\r\n\r\nWe can consider adding one or multiple references to these drafts as examples.",
          "createdAt": "2020-02-12T16:10:40Z",
          "updatedAt": "2020-02-12T16:10:40Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Could add reference to draft-ietf-alto-performance-metrics in some properties.\r\nCould add reference to draft-ietf-alto-path-vector as an example of an \"implementation\" of a similar terminology as we use.",
          "createdAt": "2020-08-26T20:25:07Z",
          "updatedAt": "2020-08-26T20:25:07Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "MDU6SXNzdWU1NDk3NDE4ODY=",
      "title": "Security/encryption property?",
      "url": "https://github.com/panrg/path-properties/issues/27",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cyrill-k"
      ],
      "labels": [],
      "body": "At IETF 106, Joachim Fabini asked whether we wanted to add a property saying something is encrypted [on a specific layer], or maybe also protected by a signature.\r\nI'm sceptical, as \"encryption is not the same as encryption\" - different protocols or algorithms have very different security properties, even though they might both \"encrypt\" a certain header or payload. In TAPS, we were heavily criticized for sounding like we can define a generic feature like \"this protocol offers encryption\", and I think defining such a path property would be the same.\r\nSo, I'm against such a property. Also, we don't have to define every property that someone can possibly think of.",
      "createdAt": "2020-01-14T18:28:36Z",
      "updatedAt": "2020-08-26T20:20:49Z",
      "closedAt": "2020-08-26T20:20:49Z",
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that an encryption/integrity protection property is quite difficult to define as we would also have to specify which entities hold en-/decryption keys and on which subpath traffic is encrypted (e.g., two local networks connected via encrypted tunnel then all nodes in the local network essentially share the keys).\r\nIt may be easier to say that encryption/integrity protection depends on the link layer/network/transport protocol used and is thus orthogonal to path properties. So if two nodes establish a VPN connection then they have encryption/integrity protection for all packets sent between them according to their respective thread model.\r\n\r\nI added PR #34, which mentions these points in the security considerations.\r\n\r\nWe could maybe define a more generic tunnel property that provides \"security\" properties such as secrecy (e.g., based on encryption or isolation) or integrity protection (e.g., based on MACs or isolation) using arbitrary means. A tunnel could be defined over a subpath. But this still needs a (generic) thread model...",
          "createdAt": "2020-02-19T11:03:48Z",
          "updatedAt": "2020-02-19T11:03:48Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "We got no feedback on this in the June 2020 PANRG interim.\r\n\r\nCan this issue be closed, at least for now?",
          "createdAt": "2020-08-15T17:37:10Z",
          "updatedAt": "2020-08-15T17:37:10Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Add something on trust (#28), then ask PANRG again.",
          "createdAt": "2020-08-26T20:20:49Z",
          "updatedAt": "2020-08-26T20:20:49Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "MDU6SXNzdWU1NDk3NDIxNjU=",
      "title": "Trust property?",
      "url": "https://github.com/panrg/path-properties/issues/28",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cyrill-k"
      ],
      "labels": [],
      "body": "Going back to comments/discussion at IETF 106, we might also want to think about modeling trust, i.e., how much a certain path element trusts another.\r\nHowever, I don't think we should do at least the trust part without a threat model, and we are not defining this threat model ourselves. Apparently, others are defining a threat model, so maybe this is something to revisit once that threat model exists. \r\nJoachim said: \"You're not defining a threat model but others are [\u2026] and it might be interesting to characterize a path wrt whether it is liable to a threat\" ",
      "createdAt": "2020-01-14T18:29:11Z",
      "updatedAt": "2020-09-04T21:56:44Z",
      "closedAt": "2020-09-04T21:56:44Z",
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "See #27 ",
          "createdAt": "2020-02-19T11:04:08Z",
          "updatedAt": "2020-02-19T11:04:08Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Could add one more example to the part where we discuss the threat model (in the Security considerations)",
          "createdAt": "2020-08-26T20:18:56Z",
          "updatedAt": "2020-08-26T20:18:56Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "MDU6SXNzdWU1NDk3NDQ0MDc=",
      "title": "Use cases",
      "url": "https://github.com/panrg/path-properties/issues/29",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "theri"
      ],
      "labels": [],
      "body": "At IETF 106, Mirja had some comments on our use cases:\r\n\r\n- Performance monitoring: She reads this as \"how is my network performing right now\", but she doesn't think that's what we are looking for in PANRG. We are more looking at general performance properties, like over the last week. She thinks this group is scoped on more long-term, not last second. I replied that we can have both short-term and long-term, but somehow for her we are talking about how we measure, and we should be talking more about definitions instead (if I understood her correctly). So I guess we should rethink this use case with Mirja's comment in mind.\r\n\r\n- Traffic configuration: Talks a lot about protocol selection. Mirja suggested that we should separate out protocol selection as its own use case, which is \"simple\" and which we understand, and then maybe extend our use cases later.",
      "createdAt": "2020-01-14T18:33:50Z",
      "updatedAt": "2020-02-19T07:52:22Z",
      "closedAt": "2020-02-19T07:52:22Z",
      "comments": []
    },
    {
      "number": 35,
      "id": "MDU6SXNzdWU1ODM0Mjg1ODA=",
      "title": "Definition of Host includes clients AND servers!?",
      "url": "https://github.com/panrg/path-properties/issues/35",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cyrill-k"
      ],
      "labels": [],
      "body": "A former colleague of mine pointed out that they weren't sure if our definition of \"host\" includes clients AND servers, or if it's only clients.\r\nThey said that \"on behalf of user(s)\" could be interpreted meaning just clients.\r\n\r\nI'm pretty sure that our definition includes clients AND servers. Do you agree, Cyrill?\r\n\r\nPerhaps we should make this definition clearer in a future revision of the draft.",
      "createdAt": "2020-03-18T03:01:12Z",
      "updatedAt": "2020-09-02T15:16:09Z",
      "closedAt": "2020-09-02T15:16:09Z",
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Maybe let's rephrase it to be more general, e.g., rephrase \"application programs\"?\r\nMaybe let's just add one sentence giving examples and then one example is a server?",
          "createdAt": "2020-08-26T20:16:33Z",
          "updatedAt": "2020-08-26T20:16:33Z"
        }
      ]
    },
    {
      "number": 36,
      "id": "MDU6SXNzdWU2NTExNjQ3MTU=",
      "title": "Double-check reference to definition of path awareness",
      "url": "https://github.com/panrg/path-properties/issues/36",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "theri"
      ],
      "labels": [],
      "body": "Double-check how we refer to the Questions draft with its definition of path awareness.\r\nMaybe we want to add/change something in the way we reference it?",
      "createdAt": "2020-07-05T23:14:22Z",
      "updatedAt": "2020-09-04T21:47:52Z",
      "closedAt": "2020-09-04T21:47:52Z",
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Maybe let's reference the questions draft in a similar way as the [\"What Not To Do\" draft](https://tools.ietf.org/html/draft-irtf-panrg-what-not-to-do-12#section-1.2) does.",
          "createdAt": "2020-08-15T17:19:13Z",
          "updatedAt": "2020-08-15T17:19:13Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Maybe rephrase the sentence in the Introduction to match the definition in the questions draft.\r\n\r\nNot sure if we should put anything in the terminology, but it would have to be clearly marked as \"not our definition\"",
          "createdAt": "2020-08-26T20:13:45Z",
          "updatedAt": "2020-08-26T20:13:45Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "MDU6SXNzdWU2Nzk2MTI4NTg=",
      "title": "Forward/reverse path is routing-specific",
      "url": "https://github.com/panrg/path-properties/issues/37",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cyrill-k"
      ],
      "labels": [],
      "body": "In the [June 2020 PANRG interim](https://datatracker.ietf.org/doc/minutes-interim-2020-panrg-01-202006031700/), Gorry commented that our current definitions of forward and reverse path are based on a routing view.\r\nThere's other properties which can make a path \"asymmetric\", e.g., based on performance characteristics.\r\n\r\nMaybe we should make it explicit that our definition refers to routing.\r\nOr on the same level of abstraction (as phrased by Spencer).",
      "createdAt": "2020-08-15T17:26:26Z",
      "updatedAt": "2020-09-04T21:52:27Z",
      "closedAt": "2020-09-04T21:52:27Z",
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually I think the following comment is also related:\r\n\r\n- Gorry: prefer something slightly different. Service functions don't\r\n          require a symmetric path - they just need to be able to observe both\r\n          directions of the flow (not even necessarily observing in the same\r\n          place - and possibly the forward/reverse path can differ after the\r\n          function). Asking just to make sure authors are thinking about this.\r\n\r\nBased on this, I would rephrase the following in our definition of \"Service function\":\r\n\r\n\"Some stateful service functions, such as NAT, require\r\n      the same instance to be involved in both directions, i.e., on the\r\n      path and the reverse path.\"\r\n\r\nCurrently it indeed sounds like the NAT requires the entire path to be symmetrical, which is not true, as Gorry points out.",
          "createdAt": "2020-08-15T17:32:57Z",
          "updatedAt": "2020-08-15T17:32:57Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Perhaps rephrase or rename our definition of \"symmetric path\" because right now it applies to routing.\r\n(For transport, a path may be asymmetric with different properties)\r\n\r\n\"Routing symmetric path\"?",
          "createdAt": "2020-08-26T20:09:17Z",
          "updatedAt": "2020-08-26T20:09:17Z"
        }
      ]
    },
    {
      "number": 46,
      "id": "MDU6SXNzdWU4NDE1MDU1OTg=",
      "title": "Clarify Node definition for microscopic context",
      "url": "https://github.com/panrg/path-properties/issues/46",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "theri"
      ],
      "labels": [],
      "body": "From Jake's review, related to the \"Node\" definition in Section 2:\r\n\r\n> Just to clarify: is for example a DSCP-selected queue in a switch a\r\n> Node under this definition?  I think so, as it may have some specific\r\n> relevant properties that are different from other queues, such as latency\r\n> targets and capacity limits.\r\n> \r\n> But as written the answer seems unclear to me, and I feel like it might\r\n> cause confusion if used that way.  Would it be helpful to include\r\n> something this as an example too?\r\n> I think the AS example shows some helpful scope in the sense that this\r\n> aggregates to a macroscopic context, but if I'm understanding correctly\r\n> that it's intended to be generalizable like this, I think it might be\r\n> helpful to clarify that depending on the properties and dynamics under\r\n> discussion, it can also be useful to slice to a more microscopic context\r\n> than a whole device or virtual device.\r\n\r\n\r\nYes, a DSCP-selected queue in a switch can be a Node.\r\n\r\nTo illustrate that a Node is not necessarily a physical or virtual machine, but can be defined in a more microscopic context, we have already included a service function as an example. To make it clearer, we can also add \"a single queue\" as another example for a (virtual) Node. ",
      "createdAt": "2021-03-26T01:21:29Z",
      "updatedAt": "2021-07-06T07:15:16Z",
      "closedAt": "2021-07-06T07:15:16Z",
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\nComment from Med:\r\n\r\n[Med] Another example we can add is the VRF or the more general concept of \"VPN Node\" defined in:\r\n\r\ndraft-ietf-opsawg-l3sm-l3nm-07:\r\n\r\n   VPN node:  An abstraction that represents a set of policies applied\r\n      on a PE and that belong to a single VPN service.  A VPN service\r\n      involves one or more VPN nodes.  As it is an abstraction, the\r\n      network controller will take on how to implement a VPN node.  For\r\n      example, typically, in a BGP-based VPN, a VPN node could be mapped\r\n      into a Virtual Routing and Forwarding (VRF).",
          "createdAt": "2021-06-22T20:38:43Z",
          "updatedAt": "2021-06-22T20:38:43Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "MDU6SXNzdWU5Mjc2MTQxOTM=",
      "title": "Clarify \"entity\"",
      "url": "https://github.com/panrg/path-properties/issues/47",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "theri"
      ],
      "labels": [],
      "body": "From Jake's review:\r\n\r\n>\u202f\r\n> I think there's a lot of use of the word \"entity\" when a narrower \"Host\"\r\n> or \"Node\" would be better.\r\n>\r\n> I'm getting a vague impression that in some situations, like when\r\n> information is exposed to an entity that can use it to achieve goals,\r\n> like in \"3. Use Cases for Path Properties\", \"entity\" is intended to\r\n> capture nodes in general plus things like traffic engineering\r\n> controllers that might have no part in a traffic path, whereas in\r\n> other cases I think it refers only to a host (like in \"3.2 Protocol\r\n> Selection\"--is there any non-host that can select a protocol for its\r\n> data traffic?  When it's sending data traffic it's acting as a host,\r\n> right?), and it would be nicer if I wasn't guessing at the intended\r\n> scope.\r\n>\r\n> I think there's a few ways to handle it, but my first suggestion would\r\n> be to use \"entity\" or \"entities\" as-is in the definitions, and try to\r\n> excise those terms from the rest of the doc, and if there are cases that\r\n> can't use a word that's in the terminology section (or combinations like\r\n> \"nodes or links\") as a substitution without losing the intended meaning,\r\n> it suggests another term might be needed.\r\n\r\nYes, \"entity\" is intended to be broader than just nodes on the path and can include off-path devices like traffic engineering controllers. It doesn't have to be a physical device either, it could also be a service running \"in the cloud\".\r\n\r\nI agree it would be good to substitute \"entity\" with a more specific term in many instances later in the document.\r\n\r\nHowever, I am not sure what a good term for these is, as I'm not sure I want to overload \"Node\". But maybe it actually is a Node, which may be on-path or off-path, and maybe in some cases it has to be on-path? (Though I imagine there could be cases where an off-path Node actually selects a protocol that some on-path Node then uses, or at least attempts to use.)\r\n\r\n",
      "createdAt": "2021-06-22T20:38:07Z",
      "updatedAt": "2021-10-21T18:19:04Z",
      "closedAt": "2021-10-21T18:19:04Z",
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Comment from Med:\r\n\r\n[Med] Agree. That can be captured by making sure to convey the message that these entities may not belong necessary to the data plane, but to the control plane.  \r\n\r\n>\u202fHowever, I am not sure what a good term for these is, as I'm not sure I want to overload \"Node\". But maybe it actually is a Node, which may be on-path or off-path, and maybe in some cases it has to be on-path?\r\n\r\n[Med] Not sure about this. I'd prefer to add an entry for \"entity\" in Section 2 to cover the intended usage (data plane, control plane, on-path, off-path, can be a node/host). \r\n\r\n>\u202f (Though I imagine there could be cases where an off-path Node actually selects a protocol that some on-path Node then uses, or at least attempts to use.)\r\n\r\n[Med] Yeah, this is for example the case of ATSSS (https://tools.ietf.org/html/draft-bonaventure-quic-atsss-overview-00#section-5.3) where the network instructs the host which protocol to use for traffic steering. ",
          "createdAt": "2021-06-22T20:39:02Z",
          "updatedAt": "2021-06-22T20:40:27Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Feedback from the IETF 111 PANRG session:\r\nWe need to be more specific. \r\n\r\nRichard basically said it only makes sense to have the entity term if all entities have something in common, otherwise it's too abstract.\r\n\r\nThis makes me think that perhaps our list of examples of what an entity could be doing is not enough. But maybe we can distill some commonalities from that list and/or our use cases? Maybe something like, an entity observes/measures path properties (or is somehow aware of them), and it can influence the path taken by flows (e.g., Path Selection) or the flow itself (e.g., Protocol Selection and Service invocation).",
          "createdAt": "2021-09-06T20:06:54Z",
          "updatedAt": "2021-09-06T20:06:54Z"
        }
      ]
    },
    {
      "number": 48,
      "id": "MDU6SXNzdWU5Mjc2MjE1ODQ=",
      "title": "Consider adding a property for broadcast capabilities for point-multipoint flows",
      "url": "https://github.com/panrg/path-properties/issues/48",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cyrill-k"
      ],
      "labels": [],
      "body": "From Jake's review:\r\n\r\n> 4.\r\n> Would it be useful to include a path property that captures the value\r\n> of broadcast capabilities for point-multipoint flows?\r\n>\r\n> Maybe something like this:\r\n>\r\n>      Replication Efficiency:  A point-multipoint flow can be transported\r\n>         over paths with a variety of replication capabilities at\r\n>         the different nodes and links along the path.  For example, an\r\n>         RTP Translator (RFC 3550) that replicates packets to multiple\r\n>         receivers by producing a separate packet for each destination\r\n>         in software has a different level of efficiency than a multicast-\r\n>         capable router or switch that uses hardware to replicate multicast\r\n>         packets to multiple interfaces, which has a different level of\r\n>         efficiency than sending multicast IP packets across a broadcast-capable\r\n>         physical link, such as GPON or MIMO broadcast channels.\r\n\r\nThanks for the suggestion.\r\n\r\nAs the examples in the document are intended to focus on properties related to the use cases in Section 3, I'm wondering what's the primary use case for this property? I imagine it might be related to protocol selection, i.e., a node could select between different protocols based on the replication efficiency of the path.\r\n\r\nCould this property also be captured by the \"Service function\" property, e.g., have the RTP Translator be a path element, and have its functionality be defined as a service function that it applies to particular flows?\r\n\r\nIs there a specific definition for a certain level of replication efficiency, e.g., is it possible to capture it as a number with a unit?",
      "createdAt": "2021-06-22T20:49:16Z",
      "updatedAt": "2021-07-05T22:11:55Z",
      "closedAt": "2021-07-05T22:11:55Z",
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "I added an example of point-to-multipoint replication efficiency to the \"protocol feature available\" property, but I'm not sure if it really fits there...\r\n\r\nHowever, I'm also fine with not adding replication efficiency as it is a very specific property not tied to our presented use cases.",
          "createdAt": "2021-07-02T15:58:59Z",
          "updatedAt": "2021-07-02T15:58:59Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing, as we closed the corresponding PR.",
          "createdAt": "2021-07-05T22:11:55Z",
          "updatedAt": "2021-07-05T22:11:55Z"
        }
      ]
    },
    {
      "number": 49,
      "id": "MDU6SXNzdWU5Mjc2MjQ0NDM=",
      "title": "Service chaining vs. endpoint services",
      "url": "https://github.com/panrg/path-properties/issues/49",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "theri"
      ],
      "labels": [],
      "body": "From [IETF 110 session](https://datatracker.ietf.org/doc/minutes-110-panrg/):\r\n\r\n\"Brian: good starting point, make sure service chaining vs. endpoint\r\n    services is clear for service invocation (here we\u2019re talking about service\r\n    chaining). This doc has the problem of context overload for all the terms.\"\r\n\r\nSee also [recording](https://youtu.be/rgaknNfvtD4?t=1648).",
      "createdAt": "2021-06-22T20:53:29Z",
      "updatedAt": "2021-07-02T08:16:43Z",
      "closedAt": "2021-07-02T08:16:43Z",
      "comments": []
    },
    {
      "number": 55,
      "id": "I_kwDOCPnxh849Cpay",
      "title": "Define \"data plane\" and \"control plane\"?",
      "url": "https://github.com/panrg/path-properties/issues/55",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In a discussion around draft-irtf-panrg-questions-10, Spencer suggested that maybe the path properties draft should define \"data plane\" and \"control plane\", as it uses these terms in the definition of \"entity\", and as other PANRG drafts also use these terms.\r\n\r\nThe path propertiest draft uses these terms only to say the following:\r\n>  an entity may be on the data plane or control plane\r\nNot sure if that makes it critical to define these terms.\r\n\r\nThe discussion around draft-irtf-panrg-questions-10 has now resulted in using an alternative term for that draft.\r\n\r\nIf we decide that the path properties draft needs to define \"control plane\" and \"data plane\", here's some first thougths:\r\n\r\nThe path properties draft already cites [RFC 7665](https://www.rfc-editor.org/rfc/rfc7665.html#section-5.2), which talks about an SFC Control plane and somewhat outlines what it is:\r\n> The SFC control plane is responsible for constructing SFPs,\r\n> translating SFCs to forwarding paths, and propagating path\r\n> information to participating nodes to achieve requisite forwarding\r\n> behavior to construct the service overlay.\r\n\r\nBut RFC 7665 states that \"the detailed definition of the SFC control plane is outside the scope of this document.\" I haven't seen other definitions in an RFC, but that doesn't mean there aren't any. Perhaps the SFC Control plane is too specific for the path properties draft anyways.\r\n\r\nDoing a web search, I found more general definitions of these terms, e.g., [here](https://www.cloudflare.com/learning/network-layer/what-is-the-control-plane/):\r\n> The control plane is the part of a network that controls how data packets are forwarded \u2014 meaning how data is sent from one place to another. The process of creating a routing table, for example, is considered part of the control plane.\r\n\r\n> In contrast to the control plane, which determines how packets should be forwarded, the data plane actually forwards the packets. The data plane is also called the forwarding plane.\r\n\r\nAny opinion?",
      "createdAt": "2021-10-12T18:10:17Z",
      "updatedAt": "2021-10-21T18:19:04Z",
      "closedAt": "2021-10-21T18:19:04Z",
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "On 10/13/21 2:00 PM, Cyrill Kr\u00e4henb\u00fchl wrote:\r\n> Regarding the control- and data-plane, I think the cloudflare definition that you cited in the github issue goes in the right direction.\r\n> I think we just have to be careful to cover all possible (future) PANs, e.g., ALTO, SCION, ... in our definition. \r\n\r\nYep, that's exactly why I'm not sure we even want to define it at all in our draft. And if the definitions are not really needed for our vocabulary, I'd prefer to omit them.\r\n\r\nIf we do include them, we'll really need to be careful to keep it general enough. The specifics of what constitutes a control or data plane are going to be specific to the used technology.\r\n\r\nAs we currently only use these words in the entity definition, perhaps we should simply rephrase that part of the definition, e.g.:\r\n\r\nOLD:\r\nWith respect to a given communication, an entity may be on the data plane or control plane\r\n\r\nNEW:\r\nWith respect to a given communication, an entity may participate in controlling how packets are forwarded, e.g., relate to the control plane, or it may actually forward the packets, i.e., relate to the data plane.\r\n\r\n> Also, differentiating between data- and control-plane might open up additional path properties, e.g., control-plane (traffic) overhead. Although I'm not sure if we really want/should to add more properties... \r\n\r\nI don't really want to add more properties.\r\n\r\nThe properties in the draft are meant as illustrative examples for the presented use cases, so I would only consider adding any properties if they really add value to the use cases, and I don't see that here.",
          "createdAt": "2021-10-14T22:34:53Z",
          "updatedAt": "2021-10-14T22:34:53Z"
        }
      ]
    },
    {
      "number": 58,
      "id": "I_kwDOCPnxh8499-Qp",
      "title": "Add \"routing domain identifier\"",
      "url": "https://github.com/panrg/path-properties/issues/58",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In PANRG discussion about draft-irtf-panrg-questions, we tripped over that draft using the term \"control plane address\", with no definition, either in draft-irtf-panrg-questions or in the path-properties draft. \r\n\r\nBased on discussion on the PANRG mailing list, we seem to be changing that to \"routing domain identifier\" (discussion thread is at https://mailarchive.ietf.org/arch/msg/panrg/BzPUTAZo0apm1HQ-wTE7xIq6g30/).\r\n\r\nShould this term be added to \"path properties\", since it's being used in our research group documents? \r\n\r\n(This is probably also a good question for @britram and @furry13}",
      "createdAt": "2021-10-29T14:56:35Z",
      "updatedAt": "2022-03-07T16:28:50Z",
      "closedAt": "2022-03-07T16:28:50Z",
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Following the discussion at the [IETF 112 PANRG session](https://youtu.be/m9uA2XKlmeU?t=516), it sounds to me like we should add this definition if it doesn't have an obvious, widely understood meaning.\r\n\r\nIt seems like \"routing domain\" does have a definition in [RFC1237](https://www.rfc-editor.org/in-notes/rfc1237.txt), it is \"a collection of networked systems that operate common routing protocols and are under the control of a single administration\".\r\nThen, [RFC 1629](https://datatracker.ietf.org/doc/html/rfc1629) defines the OSI Interdomain Routing Protocol (IDRP), which has the concept of a Routing Domain Identifier (RDI), and [RFC1930](https://www.rfc-editor.org/in-notes/rfc1930.txt) says \"It should be noted that the IDRP equivalent of an AS is the RDI, or Routing Domain Identifier.\". \r\nThese definitions seem kind of historic, and I haven't found any more current RFCs.\r\n\r\nBut I did find:\r\n- a random website claiming [a \"routing domain\" is an AS](https://www.netinbag.com/en/internet/what-is-a-routing-domain.html), so a routing domain identifier would be an ASN.\r\n- F5 defining a [route domain](https://techdocs.f5.com/kb/en-us/products/big-ip_ltm/manuals/product/tmos-routing-administration-11-6-0/8.html) as a configuration object that isolates network traffic for a particular application on the network. I'm not sure if this is the same as a routing domain, but the latter term does appear on that page, too, and it looks like it's used as a synonym.\r\n- A [patent application by Nicira](https://patents.justia.com/patent/20200382407), which talks about ways to assign a routing domain identifier to one or more logical switches, but I'm not seeing a proper definition in there.\r\n\r\nPerhaps, in the path properties draft, we could link to RFC1237 and then maybe qualify that, in the context of PANRG, a routing domain can be any collection of nodes and links which can communicate with each other, operate a common routing protocol, and are under the control of a single administration?\r\n\r\nNote that we do already define an \"Administrative Domain\", and maybe the \"routing domain\" could fit in there and/or we could change this definition to talk about routing domains instead.\r\n\r\nThoughts?",
          "createdAt": "2022-02-04T22:53:29Z",
          "updatedAt": "2022-02-04T22:53:29Z"
        },
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "I think using RFC 1237 as a reference is a good idea because our definition of administrative domain is a superset of their definition (if I understand the terms used in the RFC correctly).\r\n\r\nWe could maybe have the property **routing domain** after the property **administrative domain**, and then explicitly use your proposed (slightly modified) definition:\r\n> a routing domain is an administrative domain consisting of a collection of nodes and links which can communicate with each other and operate a common routing protocol.\r\n\r\nAnd then we also introduce the term routing domain identifier in the same paragraph.\r\n\r\nAn alternative way could be to simply merge these two property definitions, which would slightly restrict the scope of \"administrative domains\" to only cover \"routing domains\".\r\nThe only issue would then be an administrative domain that covers multiple networks with different routing protocols.\r\nHowever, I'm not sure how likely such a scenario is in practice.",
          "createdAt": "2022-02-22T19:00:27Z",
          "updatedAt": "2022-02-22T19:00:27Z"
        },
        {
          "author": "SpencerDawkins",
          "authorAssociation": "NONE",
          "body": "> The only issue would then be an administrative domain that covers multiple networks with different routing protocols.\r\n> However, I'm not sure how likely such a scenario is in practice.\r\n\r\nDo you mean different routing **protocols**, or different routing **domains**? I'm confused here. ",
          "createdAt": "2022-02-22T19:11:25Z",
          "updatedAt": "2022-02-22T19:11:25Z"
        },
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "I meant a single administrative domain that covers multiple routing domains, which potentially run different routing protocols.",
          "createdAt": "2022-02-22T19:44:54Z",
          "updatedAt": "2022-02-22T19:44:54Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Generally, I'm in favor of having fewer examples. The beginning of Section 4 says that this document covers:\r\n> [\u2026] examples of path properties which may be useful, e.g., for the use cases described in [Section 3](https://github.com/panrg/path-properties/issues/58#use-cases) [Path Selection, Protocol Selection, Service Invocation].\r\n\r\nSo, do we need \"administrative domain\" as its own separate example of a path property?\r\nI think its usefulness is mostly implied in Section 5, Security Considerations, as the trust relationship that entities need to build changes if entities are in the same administrative domain or not.\r\n\r\nI think that's enough to keep the example, as the usefulness of the administrative domain really has nothing to do with the routing protocol being used - At least I think that the routing protocol used would not change your approach to trusting a path property.\r\n\r\nThe more I think of it, the more I am against merging the \"administrative domain\" and the \"routing domain\" definitions, and in favor of keeping the administrative domain and adding a routing domain example property.\r\n\r\nIf we do keep the administrative domain example, we should change its definition, as we currently define it by itself. I remember discussing this path property example a while ago, and I don't think we could quite grasp a proper definition. Today I would say it's an individual or organization that owns a path element (or sequence of path elements).\r\n\r\nThen, perhaps a routing domain identifier could be a common identifier for a set of path elements which are owned by the same individual or organization, can communicate with each other, and where the nodes use a common routing protocol.\r\n(We do define a path property as relative to a sequence of path elements, not a set... But I suppose there's no rule saying that the same path property value can't apply to multiple path elements or paths.)\r\n\r\nWould you like to take a stab at a PR, @cyrill-k? Otherwise I'm happy to do it.",
          "createdAt": "2022-02-24T03:51:17Z",
          "updatedAt": "2022-02-24T03:51:17Z"
        }
      ]
    },
    {
      "number": 59,
      "id": "I_kwDOCPnxh849-ACu",
      "title": "Add a pointer to the repo for this draft, in the draft?",
      "url": "https://github.com/panrg/path-properties/issues/59",
      "state": "CLOSED",
      "author": "SpencerDawkins",
      "authorAssociation": "NONE",
      "assignees": [
        "theri"
      ],
      "labels": [],
      "body": "I didn't see a pointer to this repo in https://datatracker.ietf.org/doc/html/draft-irtf-panrg-path-properties-04. \r\n\r\nThe Cool Kids seem to be adding these - it's now part of https://github.com/martinthomson/i-d-template. \r\n\r\nThat gives you something like (from my most recent draft, https://github.com/SpencerDawkins/sdp-rtp-quic-questions)\r\n\r\n> Discussion Venues\r\n>\r\n> This note is to be removed before publishing as an RFC.\r\n> \r\n> Discussion of this document takes place on the \"Media Over QUIC\" non-working group mailing list (MOQ), which is archived at https://mailarchive.ietf.org/arch/browse/moq/. Subscription information is at https://www.ietf.org/mailman/listinfo/Moq/.\r\n> \r\n> Source for this draft and an issue tracker can be found at https://github.com/SpencerDawkins/sdp-rtp-quic-questions.\r\n\r\nYou might consider adding this, so that it's easier for people to find the repo. Making the obvious substitutions, of course. ",
      "createdAt": "2021-10-29T15:03:43Z",
      "updatedAt": "2022-03-01T19:16:23Z",
      "closedAt": "2022-03-01T19:16:23Z",
      "comments": []
    },
    {
      "number": 60,
      "id": "I_kwDOCPnxh85DCXNT",
      "title": "Define \"endpoint\"",
      "url": "https://github.com/panrg/path-properties/issues/60",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "theri"
      ],
      "labels": [],
      "body": "The current draft does not define \"endpoint\", and at the [IETF 112 PANRG session](https://youtu.be/m9uA2XKlmeU?t=516), several people said that perhaps this definition should be added.\r\n\r\nMany revisions ago, the document did use \"endpoint\" in its definitions ([example](https://datatracker.ietf.org/doc/draft-enghardt-panrg-path-properties/01/)), but it didn't define the term, and then we switched most of these to \"host\". \r\nNow, the term \"endpoint\" only appears in the Introduction, and two of these appearances are quotes from draft-irtf-panrg-questions.\r\n\r\nNot sure what the right path forward here is.\r\nIn the IETF 112 discussion, it sounded like an endpoint could be defined as simply the first or last node on a path, which could be a host, some proxy, a tunnel endpoint, or any other kind of node. So maybe we can add this as a separate definition and be done. \r\nOr, we could change our \"Host\" definition to \"Endpoint\" and then say that host is a specific kind of endpoint. In that case, we'll also want to revisit our definitions using \"host\", maybe these should say \"endpoint\" instead. I can already see a few places where this might be the case.",
      "createdAt": "2022-02-04T23:03:35Z",
      "updatedAt": "2022-03-01T19:29:59Z",
      "closedAt": "2022-03-01T19:29:59Z",
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "For me, the terms host and endpoint in this document are essentially synonymous, so I would be okay to change the term from host to endpoint.\r\nI think the original problem with the term endpoint was that we didn't have a clear definition.\r\nUsing the abstract notion of a node and defining the endpoint as the first/last node of a path should cover all different types of endpoints, I think.\r\n\r\nI think defining \"endpoint\" and keeping the definition of \"host\" throughout the document adds more confusion than it helps.\r\nAlso, looking through the document, I don't see any occurrence of host, where we cannot use endpoints instead.\r\n\r\nAnother possibility could be to define an endpoint in a more abstract way, e.g., \"an endpoint is an entity that is the consumer of a data received from the network and originator of data sent to the network.\". Then we could state that an endpoint is in control of the respective host and thus represents the actual source and destination.\r\n\r\nWhat do you think about these two approaches?",
          "createdAt": "2022-02-22T20:11:51Z",
          "updatedAt": "2022-02-22T20:11:51Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we should define endpoint as the first/last node of the path, and then substitute \"host\" throughput the document (and maybe say that an endpoint can be a host when we give examples).\r\nI'll put in a PR.",
          "createdAt": "2022-02-24T02:26:46Z",
          "updatedAt": "2022-02-24T02:26:46Z"
        }
      ]
    },
    {
      "number": 61,
      "id": "I_kwDOCPnxh85DCXiO",
      "title": "Define \"end-to-end\"?",
      "url": "https://github.com/panrg/path-properties/issues/61",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "theri"
      ],
      "labels": [],
      "body": "At the [IETF 112 PANRG session](https://youtu.be/m9uA2XKlmeU?t=516), Gorry suggested that maybe the path properties draft should define \"end-to-end\", a concept often talked about on the transport layer.",
      "createdAt": "2022-02-04T23:06:14Z",
      "updatedAt": "2022-03-01T19:29:59Z",
      "closedAt": "2022-03-01T19:29:59Z",
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "If we decide to add a definition of endpoint in the document (#60), then we could naturally define end-to-end as the path consisting of the sending endpoint, a virtual path element connecting them, and the receiving endpoint.\r\nAn end-to-end path property would then be define over these three entities.\r\n\r\nAlso, I think we already have an example in the definition of a path that closely resembles what I would imagine is the definition of an end-to-end path to be:\r\n> Similarly, the representation of a path and its\r\nproperties, as it is known to a specific entity, may be more\r\ncomplex and include details about the physical layer technology,\r\nor it may be more abstract and only consist of a specific source\r\nand destination which is known to be reachable from that source.",
          "createdAt": "2022-02-22T20:12:28Z",
          "updatedAt": "2022-02-22T20:12:28Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "I like this idea!\r\nI'll tackle this issue together with #60 (Define \"endpoint\").",
          "createdAt": "2022-02-24T02:27:30Z",
          "updatedAt": "2022-02-24T02:27:30Z"
        }
      ]
    },
    {
      "number": 62,
      "id": "I_kwDOCPnxh85DCY1-",
      "title": "Definitions depend on context",
      "url": "https://github.com/panrg/path-properties/issues/62",
      "state": "CLOSED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cyrill-k"
      ],
      "labels": [],
      "body": "At the [IETF 112 PANRG session](https://youtu.be/m9uA2XKlmeU?t=516), Sabine Randriamasy brought up the point that a definition can be relative to different scopes, e.g., an endpoint can mean different things in routing VS transport, or for flows VS applications.\r\n\r\nWhile Section 2.1 of the path properties draft already mentions that the terminology in the document is applicable to different technologies, maybe it should mention the different contexts as well. Or this could be part of the introduction.\r\n\r\nQuoting from two emails by @cyrill-k:\r\n> \"My suggestion is to mention in the introduction that even for a single PAN technology, there might be different contexts (e.g., data- and control-plane) where the entities might have different behavior and properties.\"\r\n> \r\n> \"[\u2026] maybe we could emphasize that even for a single PAN technology, different contexts, e.g., data- and control-plane, can use a different terminology in terms of nodes, links, and thus paths.\"",
      "createdAt": "2022-02-04T23:17:16Z",
      "updatedAt": "2022-03-02T15:15:44Z",
      "closedAt": "2022-03-02T15:15:44Z",
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it should be sufficient to add a few sentences to Section 2.1 to address the issue of contexts for specific technologies.\r\nI would not put it in the introduction, since in my opinion it is not necessary to think about different contexts to understand the terminology.\r\n",
          "createdAt": "2022-02-22T18:36:38Z",
          "updatedAt": "2022-02-22T18:36:38Z"
        }
      ]
    },
    {
      "number": 67,
      "id": "I_kwDOCPnxh85FTXLz",
      "title": "Update some references",
      "url": "https://github.com/panrg/path-properties/issues/67",
      "state": "OPEN",
      "author": "boucadair",
      "authorAssociation": "NONE",
      "assignees": [
        "theri"
      ],
      "labels": [],
      "body": "OLD: \r\n\r\n```\r\nI-D.ietf-tcpm-converters:\r\n\r\nI-D.ietf-quic-transport:\r\n```\r\n\r\nNEW:\r\n\r\n```\r\nRFC8803:\r\n\r\nRFC9000:\r\n```",
      "createdAt": "2022-03-08T14:10:16Z",
      "updatedAt": "2022-04-15T17:14:13Z",
      "closedAt": null,
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you for your comments, we'll address these in the next revision!\r\n\r\nI'm sorry for misspelling your name.\r\n\r\nCopying additional comments from the Last Call to make sure we address them all:\r\n\r\n>  (3) You may also consider adding pointers for TCPinc and MPTCP. \r\n\r\n> (4) cite 9097 in addition to 5136. \r\n\r\n> (5) s/Boudacair/Boucadair\r\n",
          "createdAt": "2022-04-15T17:14:11Z",
          "updatedAt": "2022-04-15T17:14:11Z"
        }
      ]
    },
    {
      "number": 68,
      "id": "I_kwDOCPnxh85Fqmnn",
      "title": "Nit: \"true if at least 50\\% of values are true\"",
      "url": "https://github.com/panrg/path-properties/issues/68",
      "state": "OPEN",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Finally fix the nit in the \"Aggregated property\" definition by removing a backslash - currently it says \"true if at least 50\\% of values are true\"",
      "createdAt": "2022-03-14T19:11:44Z",
      "updatedAt": "2022-03-14T19:11:44Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 69,
      "id": "I_kwDOCPnxh85H3gmE",
      "title": "Consider adding \"Target property\"",
      "url": "https://github.com/panrg/path-properties/issues/69",
      "state": "OPEN",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cyrill-k"
      ],
      "labels": [],
      "body": "Via Last Call comment by @boucadair:\r\n\r\n(1) Several application/services manipulate not only observed/assessed values, but can also set objectives/targets. I suggest we provision a new entry to cover that: \r\n\r\nNEW:\r\n   Target property:  An objective that is set for a property over a path,\r\n      subpath, or network.  For example, the maximum one-way delay to be \r\n      observed by packets transmitted from a node. Such properties can be\r\n      captured on service requests (e.g., Section 4.1.1.1 of [I-D.ietf-teas-ietf-network-slices]).      \r\n",
      "createdAt": "2022-04-15T17:11:48Z",
      "updatedAt": "2022-05-20T18:18:31Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "If I understand the idea of a target property and the IETF network slicing draft correctly, then a target property would be either an SLO or an SLE, right?\r\n\r\nI think it could be useful to have a target property, but I'm not convinced it is necessary to have a separate definition for it.\r\nIn Section 3.1, we more-or-less describe such a target property with different objectives (must involve specific nodes such as firewalls, low one-way delay paths, high BW paths).\r\nIf we introduce a new definition of target property, then some of this text could be written more concisely.\r\n\r\nAlso, similar to Spencer's point, since target properties relate to how endpoints interact with the PAN, it may make more sense to not define it in this document but a later, more appropriate document. In this document in Section 3.1, we could then just use existing terms to describe the use cases, such as SLO and SLE and reference the IETF network slicing draft.\r\n\r\n@theri what do you think?\r\n",
          "createdAt": "2022-05-12T15:13:05Z",
          "updatedAt": "2022-05-12T15:13:05Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Having read Section 4.1 of draft-ietf-teas-ietf-network-slices, I agree that an SLO is essentially a target path property. Not sure about SLEs, they appear to be somewhat more abstract, and Section 4.1.2 of draft-ietf-teas-ietf-network-slices says \"SLEs may be seen as aspirational on the part of the customer, and they are expressed as behaviors that the provider is expected to apply to the network resources used to deliver the IETF Network Slice service. Of course, over time, it is possible that mechanisms will be developed that enable a customer to verify the provision of an SLE, at which point it effectively becomes an SLO.\"\r\nPath properties in draft-irtf-panrg-path-properties can be observed/measured or assessed (we have definitions for these), which means that there are \"mechanisms [\u2026] that enable a customer to verify the provision of an SLE\".\r\nThat said, I guess Section 3.1 of draft-irtf-panrg-path-properties does describe both SLOs and SLEs, i.e., involving a specific firewall seems more like a \"Security SLE\" than an SLO.\r\n\r\nI am not sure if draft-irtf-panrg-path-properties should attempt to neatly classify target properties as SLOs or SLEs, and I actually think it might be easier to just add the \"Target Property\" definition, give SLOs and SLEs as an example (there are other ways to conceptualize target properties for sure), and then use \"target property\" in Section 3.1.\r\nWhen doing so, Section 3.1 could also explicitly point out the relationship between target properties and observed/assessed properties. Currently, we define observed property and assessed property, but we never use these definitions.\r\n\r\nI agree that a future document could expand on the interaction between entities when doing Path Selection, who exactly measures properties and how, etc. But I don't think this should preclude us from talking about target properties in this draft already.\r\n\r\nSo, what do you think about adding the \"target property\"\u202fdefinition and rewriting Section 2.1 to use that definition as well as the \"observed property\" and \"assessed property\"?",
          "createdAt": "2022-05-20T18:18:30Z",
          "updatedAt": "2022-05-20T18:18:30Z"
        }
      ]
    },
    {
      "number": 70,
      "id": "I_kwDOCPnxh85H3ltn",
      "title": "Try to make path definition clearer/more readable",
      "url": "https://github.com/panrg/path-properties/issues/70",
      "state": "OPEN",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "cyrill-k"
      ],
      "labels": [],
      "body": "Via @SpencerDawkins in Last Call:\r\n\r\n> In the definition of \u201cPath\u201d, \r\n>\r\n> For multicast or broadcast, a packet may be sent by one node and received by multiple nodes. In this case, the packet is sent over multiple paths at once, one path for each combination of sending and receiving node; these paths do not have to be disjoint.\r\n>\r\n> I think the point this text is making is that if a sending node performs broadcast or multicast over multiple paths, that\u2019s not relevant to the definition of a path in this document - each one of the paths from sender to receiver(s) is just another path, according to this definition. \r\n>\r\n> Is that correct? If so, perhaps this could be a second paragraph on its own within the definition, to be clearer. \r\n\r\nYes, I would say that this is correct.\r\n\r\nIn general, I think the Path definition is quite long and includes lots of aspects. I'll see what we can do to make it clearer.",
      "createdAt": "2022-04-15T17:41:00Z",
      "updatedAt": "2022-05-12T15:26:16Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "One easy fix could be to make the path definition minimal, i.e., \"A sequence of adjacent path elements over which a packet can be transmitted, starting and ending with a node. A path is unidirectional.\".\r\nAnd then have the rest of the explanations in a separate paragraph below.\r\n\r\nI think we can maybe rearrange some of the text to make the text clearer.\r\nI can do a first pass for the rephrasing and make a PR.",
          "createdAt": "2022-05-12T15:26:16Z",
          "updatedAt": "2022-05-12T15:26:16Z"
        }
      ]
    },
    {
      "number": 71,
      "id": "I_kwDOCPnxh85H3l0P",
      "title": "Rephrase sentence in Transparency definition",
      "url": "https://github.com/panrg/path-properties/issues/71",
      "state": "OPEN",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "theri"
      ],
      "labels": [],
      "body": "Via @SpencerDawkins in Last Call:\r\n\r\n> In the definition of \u201cTransparency\u201d, I found this sentence difficult to parse: \r\n>\r\n> A can for example be blocking packets or reading and modifying (other protocol) headers or payloads.\r\n>\r\n> Perhaps\r\n>\r\n> For example, A can be blocking packets or reading and modifying (other protocol) headers or payloads.",
      "createdAt": "2022-04-15T17:41:46Z",
      "updatedAt": "2022-05-20T18:19:02Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good to me :+1: ",
          "createdAt": "2022-05-12T15:26:44Z",
          "updatedAt": "2022-05-12T15:26:44Z"
        }
      ]
    },
    {
      "number": 72,
      "id": "I_kwDOCPnxh85H3l7R",
      "title": "Add point about the usefulness of dynamic path properties",
      "url": "https://github.com/panrg/path-properties/issues/72",
      "state": "OPEN",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "theri"
      ],
      "labels": [],
      "body": "Via @SpencerDawkins in Last Call:\r\n\r\n> I\u2019m not sure where to put it, but some of the dynamic path properties can be so dynamic that they aren\u2019t useful in path-aware networking. For example, link usage for bursty traffic may vary so dramatically that this property can\u2019t be used to select between paths without applying dampening or otherwise avoiding oscillation. This is somewhat related to https://www.rfc-editor.org/rfc/rfc9049.html#name-reacting-to-distant-signals, and has been mentioned about every two years for the entire time ALTO has been chartered. \ud83d\ude42\r\n>\r\n> Perhaps following this paragraph? \r\n>\r\n> Some path properties express the performance of the transmission of a packet or flow over a link or subpath. Such transmission performance properties can be measured or approximated, e.g., by endpoints or by path elements on the path, or they may be available as cost metrics, see [I-D.ietf-alto-performance-metrics]. Transmission performance properties may be made available in an aggregated form, such as averages or minimums. Properties related to a path element which constitutes a single layer 2 domain are abstracted from the used physical and link layer technology, similar to [RFC8175].",
      "createdAt": "2022-04-15T17:42:35Z",
      "updatedAt": "2022-05-20T18:19:41Z",
      "closedAt": null,
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with you that a clear classification of properties is difficult.\r\nMaybe we can add some text to discuss that some properties are more dynamic or more distant than others?",
          "createdAt": "2022-05-12T15:37:40Z",
          "updatedAt": "2022-05-12T15:37:40Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes. I can take a first stab at this text.",
          "createdAt": "2022-05-20T18:19:41Z",
          "updatedAt": "2022-05-20T18:19:41Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 4,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU3MDMzNTk1",
      "title": "Wireless properties, MTU",
      "url": "https://github.com/panrg/path-properties/pull/4",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This (really short) Pull Request substitutes the Wireless properties with the more abstract data rates based on RFC 8175.\r\nAlso, I substituted \"available bandwidth\" (capacity) with \"maximum data rate\" in the process, because it's actually the same thing, just available bandwidth (capacty) is supposed to apply to the entire path instead of just one link.\r\nNow this is the theoretical maximum of all links on the path, which might be different from the actually achievable throughput on this path. But I'm not sure we will be able to specify the actually achievable throughput on a path with the definition of path on a per-packet basis and with flows... maybe the flow can have a maximum throughput later? But that's future work.\r\n\r\nIn this PR, I'm not sure if we need to reference RFC 8175? It inspires our definition, but then again, it's not like they provide an entirely novel thing... And DLEP would be a way to gather these properties, but how to gather properties is out of scope for our draft.\r\n\r\nAny opinions?",
      "createdAt": "2019-02-28T11:32:28Z",
      "updatedAt": "2019-10-22T15:38:46Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "74dcac78643b402777708a9e02b75b8f12d9daca",
      "headRepository": "panrg/path-properties",
      "headRefName": "physical-layer-properties",
      "headRefOid": "26a239f1416c61ff30c86f57ef810c38ef8ff589",
      "closedAt": "2019-03-04T18:57:38Z",
      "mergedAt": "2019-03-04T18:57:38Z",
      "mergedBy": "theri",
      "mergeCommit": {
        "oid": "f56fe0c088f5a36397f6b77567c7e585f9595d8d"
      },
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "I also like maximum data rate more than \"achievable throughput\" as the achievable throughput depends on e.g., the protocol and congestion control algorithms used.\r\nI think I would cite RFC8175 to show that our wireless path properties are also defined elsewhere in this way.",
          "createdAt": "2019-02-28T17:53:56Z",
          "updatedAt": "2019-02-28T17:53:56Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Okay, I added a sentence referencing RFC 8175.\r\nAlso, I substituted \"end-to-end bandwidth\" in the text, because we don't have that anymore, with \"end-to-end latency\", because we will most likely keep this one.\r\nDoes this work?",
          "createdAt": "2019-03-01T16:10:56Z",
          "updatedAt": "2019-03-01T16:10:56Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEwMjY2ODMw",
          "commit": {
            "abbreviatedOid": "26a239f"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-04T17:22:12Z",
          "updatedAt": "2019-03-04T17:22:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 5,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU4Mjg2ODUw",
      "title": "Terminology",
      "url": "https://github.com/panrg/path-properties/pull/5",
      "state": "MERGED",
      "author": "cyrill-k",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addition of a Terminology section, describing path element, path, flow, aggregated property, measured & potential property.",
      "createdAt": "2019-03-05T11:25:05Z",
      "updatedAt": "2019-10-22T15:38:51Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "f56fe0c088f5a36397f6b77567c7e585f9595d8d",
      "headRepository": "panrg/path-properties",
      "headRefName": "terminology",
      "headRefOid": "bdebff218fd74efb2086f7a5a2d324c12b28e242",
      "closedAt": "2019-03-08T09:38:07Z",
      "mergedAt": "2019-03-08T09:38:07Z",
      "mergedBy": "cyrill-k",
      "mergeCommit": {
        "oid": "8c45670fe752cf107e142ba00e754bae5d84d7e0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEwODI0OTc1",
          "commit": {
            "abbreviatedOid": "4051123"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thank you for this PR!\r\nI quite like the definitions of path elements and path now.\r\n\r\nI added a few questions and suggestions -- let me know what you think.",
          "createdAt": "2019-03-05T17:52:13Z",
          "updatedAt": "2019-03-05T18:02:36Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Here you mean \"link used to connect two devices\", not just endpoints, right?",
              "createdAt": "2019-03-05T17:52:13Z",
              "updatedAt": "2019-03-08T09:37:27Z"
            },
            {
              "originalPosition": 12,
              "body": "Do we still need this part about packet being defined on every layer? Maybe we can drop this, as I think it confuses matters?",
              "createdAt": "2019-03-05T17:53:52Z",
              "updatedAt": "2019-03-08T09:37:27Z"
            },
            {
              "originalPosition": 15,
              "body": "By this, we mean between two endpoints, in which case it would be \"traversing the same path at specific points in time\", instead of path elements? Or is this also defined on a part of the path?",
              "createdAt": "2019-03-05T17:55:37Z",
              "updatedAt": "2019-03-08T09:37:27Z"
            },
            {
              "originalPosition": 11,
              "body": "What do we mean by \"at specific points in time\"? Isn't it implied by \"traversed by a packet\" that this happens at specific points in time? \r\nI think maybe we could drop the \"at specific points in time\".",
              "createdAt": "2019-03-05T17:57:02Z",
              "updatedAt": "2019-03-08T09:37:27Z"
            },
            {
              "originalPosition": 23,
              "body": "nit: s/individual path element/individual path elements/",
              "createdAt": "2019-03-05T17:58:56Z",
              "updatedAt": "2019-03-08T09:37:27Z"
            },
            {
              "originalPosition": 27,
              "body": "Maybe here an example for a potential property would be useful.\r\nIs this like \"expected one-way latency of packets during the next second\"?\r\nThis would invite the question of how we can even know this. But I would be okay with leaving it in for now and see what PANRG thinks.",
              "createdAt": "2019-03-05T18:01:07Z",
              "updatedAt": "2019-03-08T09:37:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExMjI0NDc5",
          "commit": {
            "abbreviatedOid": "4051123"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-06T13:20:32Z",
          "updatedAt": "2019-03-06T13:20:32Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I think we can drop it, and if someone complains (e.g., \"its not packets, but datagrams that are sent within a UDP session\"), then we can either insert it again or fix each inexact use of \"packet\".",
              "createdAt": "2019-03-06T13:20:32Z",
              "updatedAt": "2019-03-08T09:37:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExMjI2MDA0",
          "commit": {
            "abbreviatedOid": "4051123"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-06T13:23:57Z",
          "updatedAt": "2019-03-06T13:23:57Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I guess it does not add any relevant information so we can remove it.",
              "createdAt": "2019-03-06T13:23:57Z",
              "updatedAt": "2019-03-08T09:37:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExMjI4NzEy",
          "commit": {
            "abbreviatedOid": "4051123"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-06T13:29:28Z",
          "updatedAt": "2019-03-06T13:29:29Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I would keep the definition on a part of the path instead of on a complete path, in order to be able to for example specify: \"median one-way delay outside of local network\", which is the median delay of the flow after the second hop to the endpoint.",
              "createdAt": "2019-03-06T13:29:29Z",
              "updatedAt": "2019-03-08T09:37:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExMjMzODEy",
          "commit": {
            "abbreviatedOid": "4051123"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-06T13:40:06Z",
          "updatedAt": "2019-03-06T13:40:06Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "What do you think about the following two examples?\r\n\r\nAn example of a potential property with a high reliability is the maximum data rate of an ethernet link in the local network during the next day, while a potential property with a lower reliability is the expected one-way latency of packets sent to an endpoint on the other side of the planet during the next second.",
              "createdAt": "2019-03-06T13:40:06Z",
              "updatedAt": "2019-03-08T09:37:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExMjUzNDEx",
          "commit": {
            "abbreviatedOid": "dd8ae0f"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-06T14:18:54Z",
          "updatedAt": "2019-03-06T14:20:27Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Seems like a good starting point. However, now \"reliability\" is only loosely defined, and I'm not sure if that could be a problem. When I read \"reliability\", first I was thinking about some statistical error margin or something like this.\r\nMaybe it helps to add another sentence saying what we mean with reliability here? It's an indication of how likely this property is going to be close to the actually measured property, or something like this, right?",
              "createdAt": "2019-03-06T14:18:54Z",
              "updatedAt": "2019-03-08T09:37:27Z"
            },
            {
              "originalPosition": 15,
              "body": "Fine with me, it does seem more useful to also have it apply on part of the path.",
              "createdAt": "2019-03-06T14:20:27Z",
              "updatedAt": "2019-03-08T09:37:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExMjU0ODky",
          "commit": {
            "abbreviatedOid": "dd8ae0f"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for addressing the comments. I have one more comment about the reliability part, otherwise I think this is ready for feedback from the Research Group.",
          "createdAt": "2019-03-06T14:21:40Z",
          "updatedAt": "2019-03-06T14:21:40Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExMzkzMDE1",
          "commit": {
            "abbreviatedOid": "dd8ae0f"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-06T18:18:57Z",
          "updatedAt": "2019-03-06T18:18:57Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I guess depending on the type of property, the reliability is defined differently, a statistical error margin for numerical values, a probability distribution for categorical values, ...\r\n\r\nI guess if we want to have a more formal definition it would be something like (I didn't think thoroughly about this ;):\r\nA potential property *P* is a predicate over a (set of) properties and a time *t* evaluating to true or false depending if some statement holds or does not hold at time *t* (e.g., RTT is between 50 and 100ms in 1 second).\r\nThe reliability of a potential property at time *t* is defined as the likelihood of *P* being true.\r\n\r\nBut I think this would be out of scope of this draft...",
              "createdAt": "2019-03-06T18:18:57Z",
              "updatedAt": "2019-03-08T09:37:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExNDAwNzkw",
          "commit": {
            "abbreviatedOid": "dd8ae0f"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-06T18:34:41Z",
          "updatedAt": "2019-03-06T18:34:41Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "You're right, also for non-numerical properties this might be very different than for numerical properties.\r\nI'm okay with leaving it like it is for now and see what the Research Group says.",
              "createdAt": "2019-03-06T18:34:41Z",
              "updatedAt": "2019-03-08T09:37:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExNjk1ODQ3",
          "commit": {
            "abbreviatedOid": "dd8ae0f"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-07T10:10:06Z",
          "updatedAt": "2019-03-07T10:10:07Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Maybe we can just add this sentence and not specify a concrete definition:\r\nThe notion of reliability depends on the property, it might be the confidence level and interval for numerical properties or the likelihood that a property holds for non-numerical properties.",
              "createdAt": "2019-03-07T10:10:07Z",
              "updatedAt": "2019-03-08T09:37:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExNjk3NzI2",
          "commit": {
            "abbreviatedOid": "dd8ae0f"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-07T10:14:02Z",
          "updatedAt": "2019-03-07T10:14:02Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Sounds good to me! :)",
              "createdAt": "2019-03-07T10:14:02Z",
              "updatedAt": "2019-03-08T09:37:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 6,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU4NzEyNjAz",
      "title": "PAN not only for endpoints. Added three scenarios of systems using PAN.",
      "url": "https://github.com/panrg/path-properties/pull/6",
      "state": "MERGED",
      "author": "cyrill-k",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Motivation for why we need the path properties we decided to list.\r\nWhat do you think about this list?\r\n\r\nSo far I only added three systems that can use the path properties, but did not specifically say which properties are relevant for which system (e.g., achievable data rate is relevant for p2p file sharing systems). I'm not sure how much into detail we should go here...",
      "createdAt": "2019-03-06T13:09:56Z",
      "updatedAt": "2019-10-22T15:38:48Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "f56fe0c088f5a36397f6b77567c7e585f9595d8d",
      "headRepository": "panrg/path-properties",
      "headRefName": "motivation",
      "headRefOid": "e172e5f0535bfbb0cd98eec34eb53bcb0471e182",
      "closedAt": "2019-03-08T13:45:43Z",
      "mergedAt": "2019-03-08T13:45:43Z",
      "mergedBy": "theri",
      "mergeCommit": {
        "oid": "2edc302b777af2fc1709f469545984134209c97e"
      },
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "I just went over my notes from IETF 103 again, and I noticed three more points that perhaps make sense to include in the path selection use case:\r\n- Such path selection might hope to be \"better than random\".\r\n- Path properties may come with limiltations, e.g., performance-related path properties measured in the past may become outdated and not related to path properties of packets sent now.\r\n- There are trade-offs between different performance-related path properties, e.g., latency and data rate. What constitutes \"good performance\" also depends on the application's needs.\r\n\r\nThis is quite a lot, I realize. I can also put in these parts later in a new PR.\r\nI'm just trying to incorporate as many IETF 103 comments as possible before going back and asking the Research Group whether we are on the right track.",
          "createdAt": "2019-03-06T17:07:23Z",
          "updatedAt": "2019-03-06T17:07:41Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExMjYxMTk0",
          "commit": {
            "abbreviatedOid": "d3e2de2"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thank you for putting this together.\r\n\r\nI agree with PAN being not only for endpoints, but also for other devices (on the path, in the operator's network but somehow related to a path or flow, ...).\r\n\r\nAbout the use cases (I think that's what they are), I have though about this quite a bit now, and I think this is generally on the right track. We provide use cases as motivation why we include certain path properties and not others. However, the individual use cases are not yet clear to me. \r\nI do have a loose understand of where you're trying to go with them though, and I'm sure we can figure this out. :)\r\n\r\nIdeally, we should be able to later motivate each of our path properties with at least one of these use cases.\r\nWith that in mind, I'm currently wondering about Path Disjointness - this could be relevant to path selection, our third use case, right? And perhaps policy, too? I'm having trouble imagining in what exact way Path Disjointness could be relevant, i.e., whether we are missing a use case or aspect of a use case here.\r\nBut maybe it will all become clearer once we define properties such as Path Disjointness more formally.",
          "createdAt": "2019-03-06T14:33:26Z",
          "updatedAt": "2019-03-06T15:35:34Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "What does \"broadly relevant\" mean?\r\nMaybe we want something like: \"In this document, we specify a set of path properties which might inform the following use cases: Traffic policies, network monitoring, and path selection.\"\r\n\r\nAnd then we can have the three use cases as a list (written with \"-\" as bullet point in markdown):\r\n- Traffic policies: ...\r\n- Network monitoring: ...\r\n- Path selection: ...",
              "createdAt": "2019-03-06T14:33:26Z",
              "updatedAt": "2019-03-08T13:17:18Z"
            },
            {
              "originalPosition": 21,
              "body": "I'm not quite sure I understand this use case yet, and how it relates to the knowledge about certain path properties.\r\nMaybe it would help to give examples of who might define such traffic policies (network operators? end users?) and what path properties they might use. I think it's better to use active voice than passive voice anyway (\"can be defined\" --> \"network operators or end users can define ...\").\r\n\r\nIn the example given here, I just realized that we have this as a property (whether a certain transport protocol works or not), but it's not like the devices on the path tell us whether they block QUIC -- an endpoint would just have to try a QUIC handshake and fall back to TCP if it doesn't work, right? Then the endpoint could cache the \"Transport protocols available\" property with its knowledge of whether the endpoint has established a QUIC connection successfully in the past (certain time period), and then the endpoint could be \"more confident\" in just using QUIC, i.e., it could put less resources into trying out different protocols. But to me, this is not really a policy or a matter of allowing or not allowing traffic, but more, like, an opportunity for performance optimization.\r\n\r\nMaybe we can find a more obvious example of an actual policy here.\r\nI'm thinking along the lines of:  An end user might define a policy that they prefer their traffic to pass through a specific network, e.g., their home network rather than a public cellular network. To inform such a policy, it might be useful for the end user to know about properties of the paths such as Monetary Cost or the presence of a specific network on the path (i.e., a fixed-line network where they have a flat-rate contract with the provider, as opposed to a cellular network where the provider charges based on data traffic volume).\r\n\r\nMaybe we can also find a policy use case with firewalls or proxies, but I'm not sure if those are easier to understand and agree with for our audience.",
              "createdAt": "2019-03-06T15:01:01Z",
              "updatedAt": "2019-03-08T13:17:18Z"
            },
            {
              "originalPosition": 24,
              "body": "Here I'm also not quite sure I understand the use case(s).\r\nWhat does it mean to \"associate their measurements with the actual path used\"? A monitoring system gets information from on-path devices, e.g., latency measurements, and then it can compare them to... what exactly? Path properties advertised where? In some contract that specifies certain latency properties? Or in some future path-awareness protocol that communicates some network performance to endpoints, and a different party (who?) wants to find out if this information is true?\r\nIn the second sentence, do you mean that a network operator could use on-path measurements to, e.g., write somewhere that their 95th quantile latency is x milliseconds, or that their median packet loss is x %? I'm not sure in what specific scenario this would actually happen.\r\n\r\nMaybe it's easier to start with something simpler, where we only observe performance and don't promise or advertise anything yet. For example, \"Network operators can use path properties, e.g., measured by on-path devices, to check whether recent end-user traffic satisfy specific Quality of Service (QoS) requirements, and identify potential problems with their network early on, before the end-user complains\"?\r\nPerhaps here we could cite something later on, like, IPPM or IPFIX or something? I'm not sure I fully understand the context in which these protocols are actually used though...",
              "createdAt": "2019-03-06T15:14:15Z",
              "updatedAt": "2019-03-08T13:17:18Z"
            },
            {
              "originalPosition": 27,
              "body": "Here we mean on an AS level, right? Would that be path properties like \"what ASes are further along the path\", in a sense of \"who is operating them\", or something like this? If so, isn't this more about policy and less about efficient resource usage? Or are there other path properties that make sense of an AS level for resource usage, which are not covered by usual BGP attributes (local preference? or was that MED?)?\r\nWe should make sure that this use case clearly differs from the policy use case above.",
              "createdAt": "2019-03-06T15:21:41Z",
              "updatedAt": "2019-03-08T13:17:18Z"
            },
            {
              "originalPosition": 29,
              "body": "Optimal in what sense? Less latency? And based on what path properties? In ALTO it was some knowledge of the topology within an AS, or something like that, right?\r\nI'm not sure we have to be that specific, but I would at least like to have a hint of what kind of properties might be useful for this use case.",
              "createdAt": "2019-03-06T15:23:25Z",
              "updatedAt": "2019-03-08T13:17:18Z"
            },
            {
              "originalPosition": 26,
              "body": "More optimal usage of networked resources means something like load balancing, right? So the resource is available link capacity?\r\n\r\nWith path selection, we might also be trying to achieve better (end-to-end) performance, right? I think we should name this aspect here as well, and then provide some examples to illustrate both goals.",
              "createdAt": "2019-03-06T15:32:28Z",
              "updatedAt": "2019-03-08T13:17:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExNzAyMDY0",
          "commit": {
            "abbreviatedOid": "d3e2de2"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-07T10:23:12Z",
          "updatedAt": "2019-03-07T10:23:12Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I don't like the wording of \"informing a use case\". Maybe we can write it like this:\r\n\"In this document, we specify a set of path properties which might be useful in the following use cases: Traffic policies, network monitoring, and path selection.\"\r\n\r\n- Traffic Policies\r\n- ...",
              "createdAt": "2019-03-07T10:23:12Z",
              "updatedAt": "2019-03-08T13:17:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExNzMwODc0",
          "commit": {
            "abbreviatedOid": "d3e2de2"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-07T11:29:16Z",
          "updatedAt": "2019-03-07T11:29:16Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I'll change to active voice.\r\n\r\nMaybe blocking UDP traffic is not a good example. Should we use the following examples (one for each of the use cases):\r\n\r\n- An endpoint might require either an on-path or locally installed firewall to send or receive traffic.\r\n\r\n- Endpoints communicating with each other within a trusted network might forgo encryption, such as TLS, as long as all devices and links are within the network.\r\n\r\n- A video streaming application chooses an (initial) video quality based on the achievable data rate, or the monetary cost of the link, whether path uses a volume-based cost model or a flat-rate model.\r\n\r\nAlthough I'm not too sure about the firewall & encryption example as some people might be hesitant to use path properties for security purposes (is the entity providing path properties trusted? Are path properties authenticated? Are the capabilities of each device authenticated?)...\r\n",
              "createdAt": "2019-03-07T11:29:16Z",
              "updatedAt": "2019-03-08T13:17:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExNzUyMjE3",
          "commit": {
            "abbreviatedOid": "d3e2de2"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-07T12:24:12Z",
          "updatedAt": "2019-03-07T12:24:13Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Sure, that works too!",
              "createdAt": "2019-03-07T12:24:12Z",
              "updatedAt": "2019-03-08T13:17:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExNzU2MzE4",
          "commit": {
            "abbreviatedOid": "d3e2de2"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-07T12:34:46Z",
          "updatedAt": "2019-03-07T12:34:46Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "All of these examples are about policy, i.e., the first use case, right? \r\nYes, I'm not sure about using security examples either, if we do not have anything on trustworthiness path properties yet (which is out of scope for our draft, but still, it would bother me as well). \r\nHowever, maybe we could use the first example, e.g., say that in an enterprise network there is a policy that all traffic has to go through a firewall, and then the endpoint wants to be aware of that... about the locally-installed firewall, I'm not sure what it has to do with path properties, as it's all local.\r\nThe third example is a good convincing one to me.\r\n\r\nI just realized that these examples are also about path selection, just like the name of our third use case, so maybe we have to name the third use case not \"path selection\" but \"traffic optimization\" or something similar, to highlight that the third use case is about resource usage and/or performance, not policy.",
              "createdAt": "2019-03-07T12:34:46Z",
              "updatedAt": "2019-03-08T13:17:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExODcyOTg5",
          "commit": {
            "abbreviatedOid": "5370838"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-07T16:09:21Z",
          "updatedAt": "2019-03-07T16:09:22Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Sorry for the confusion. What I meant to say is they are for different aspect of the first use case \"traffic policies\".\r\n\r\nI think \"traffic policies\" is about path transparency (knowledge about existing paths) rather than path choice (which is handled in the third use case), since we always work with (possibly one) existing path. I would rather keep the title of the third use case as \"path selection\", as our first use case also has aspects of \"traffic optimization\".\r\n\r\nI chose the following two examples. Are they good this way?\r\nAn example of a traffic policy is a video streaming application choosing an (initial) video quality based on the achievable data rate, or the monetary cost of the link using a volume-based or flat-rate cost model.\r\nAnother example is an enterprise network where all traffic has to go through a firewall, in which case the endpoint needs to be aware of on-path firewalls.",
              "createdAt": "2019-03-07T16:09:22Z",
              "updatedAt": "2019-03-08T13:17:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExODc2OTMy",
          "commit": {
            "abbreviatedOid": "5370838"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-07T16:15:46Z",
          "updatedAt": "2019-03-07T16:15:46Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "I agree that it is probably better to make a simple statement that does not require many assumptions. I adjusted the example in the pull request. I think it is fine the way it is now since we only need these use cases to justify our choice of path properties and since most path properties can be relevant for QoS, we should be fine ;)\r\n\r\nI'm also not an expert on either of these protocols, but I will take a look at them to see how to justify our properties.",
              "createdAt": "2019-03-07T16:15:46Z",
              "updatedAt": "2019-03-08T13:17:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExODgzOTAx",
          "commit": {
            "abbreviatedOid": "5370838"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-07T16:27:09Z",
          "updatedAt": "2019-03-07T16:27:09Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I guess for AS level path selection, the difference between path selection and traffic policy is very small, as the way ASes setup their policies is by selecting paths...\r\n\r\nI guess for ASes (assuming they use BGP), \"traffic policies\" mean allowing and disallowing certain AS paths based on information from path properties about these ASes; and \"path selection\" means choosing the paths with the most benefits (e.g., lowest latency, highest maximum data rate, best load balancing, ...).\r\nI think in BGP, regarding performance, we can only argue about intra-network links and links incoming and outgoing of the network, since we have little information about the rest of the path (list of AS numbers only).",
              "createdAt": "2019-03-07T16:27:09Z",
              "updatedAt": "2019-03-08T13:17:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExODg1MTA1",
          "commit": {
            "abbreviatedOid": "5370838"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-07T16:29:10Z",
          "updatedAt": "2019-03-07T16:29:11Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Yep, I think we can use these examples like that.\r\nAnd yes, I agree to leave path selection separate from \"traffic policies\".",
              "createdAt": "2019-03-07T16:29:10Z",
              "updatedAt": "2019-03-08T13:17:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExODg1NDA4",
          "commit": {
            "abbreviatedOid": "5370838"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-07T16:29:41Z",
          "updatedAt": "2019-03-07T16:29:41Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Removed statement about \"optimal\" paths. Added a sentence that paths with different properties might be preferred in the beginning of this issue.",
              "createdAt": "2019-03-07T16:29:41Z",
              "updatedAt": "2019-03-08T13:17:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExODg1ODE2",
          "commit": {
            "abbreviatedOid": "5370838"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-07T16:30:18Z",
          "updatedAt": "2019-03-07T16:30:19Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "Cool, thanks!",
              "createdAt": "2019-03-07T16:30:19Z",
              "updatedAt": "2019-03-08T13:17:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExODg3NzUx",
          "commit": {
            "abbreviatedOid": "5370838"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-07T16:33:34Z",
          "updatedAt": "2019-03-07T16:33:34Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Example for AS path selection: Load balancing\r\nGeneral example for path selection: reduce webpage load time & retrieving large file in p2p network.",
              "createdAt": "2019-03-07T16:33:34Z",
              "updatedAt": "2019-03-08T13:17:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExODk3NDc1",
          "commit": {
            "abbreviatedOid": "5370838"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": ">* Such path selection might hope to be \"better than random\".\r\n>* Path properties may come with limitations, e.g., performance-related path properties measured in the past may become outdated and not related to path properties of packets sent now.\r\n>* There are trade-offs between different performance-related path properties, e.g., latency and data rate. What constitutes \"good performance\" also depends on the application's needs.\r\n\r\nI tried to add these points to the definition of \"Path selection\".\r\nPlease tell me if this is what you had in mind or if I completely missed your points ;)\r\n\r\n> Ideally, we should be able to later motivate each of our path properties with at least one of these use cases.\r\nWith that in mind, I'm currently wondering about Path Disjointness - this could be relevant to path selection, our third use case, right? And perhaps policy, too? I'm having trouble imagining in what exact way Path Disjointness could be relevant, i.e., whether we are missing a use case or aspect of a use case here.\r\nBut maybe it will all become clearer once we define properties such as Path Disjointness more formally.\r\n\r\nI think justifying path disjointness (number of common links and/or devices) is quite straightforward, since for a multipath protocol, reducing the number of shared points of failure (whether it is a common link or a common device), is useful to maximize the reliability of the multipath session.\r\nThis (and multipath) would then correspond to \"path selection\" I guess.",
          "createdAt": "2019-03-07T16:50:01Z",
          "updatedAt": "2019-03-07T16:50:01Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExODkzMjAw",
          "commit": {
            "abbreviatedOid": "5370838"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for the update, it addresses most of my comments quite nicely and now I feel more like this is really cool stuff. :)\r\n\r\nThis is almost ready. I have a few more comments, mostly minor. \r\nI guess I have a particular view on path selection, as my thesis is based on it... ;)",
          "createdAt": "2019-03-07T16:42:49Z",
          "updatedAt": "2019-03-07T17:10:46Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Maybe a nit, but I think this list of who can define policies is not exhaustive, as applications or operating systems might define or influence such policies as well (e.g., an application for its own traffic). \r\nWe had lots of discussions on policy in TAPS already, and I don't think we want to rehash them in PANRG and in this draft. \r\nSo let's just be more general and give two examples:\r\n\"Entities such as network operators or end users may want to define traffic policies leveraging path awareness.\"\r\n\r\n(I'm not sure if they actually \"can\" do that yet, but perhaps that's another nit... ;) I guess I would write \"may want to\" or \"could\" for this hypothethic scenario.)",
              "createdAt": "2019-03-07T16:42:49Z",
              "updatedAt": "2019-03-08T13:17:18Z"
            },
            {
              "originalPosition": 25,
              "body": "Perhaps a nit, but I'm stumbling over \"to check whether [recent end-user traffic] satisfies specific Quality of Service (QoS) requirements\", as it sounds like there's traffic that needs certain QoS guarantees and that there's a way to provide such guarantees. Our example is not restricted to such a use case.\r\n\r\nHow about something even more open instead, like \"to observe the Quality of Service (QoS) characteristics of recent end-user traffic\", and then the rest of the sentence still makes sense in this context?",
              "createdAt": "2019-03-07T16:49:50Z",
              "updatedAt": "2019-03-08T13:17:18Z"
            },
            {
              "originalPosition": 28,
              "body": "I'm not sure if this can actually be a guarantee (as I'm just finding out in my research, sometimes being too smart in distributing traffic may hurt performance in some cases, because I might regret my decision in a few miiliseconds if other traffic is coming that I didn't know about yet... I think I can't fully prevent this from happening as I can't see the future, I can only reduce the number of cases in which it happens by being even smarter).\r\nI would make this a bit weaker by saying \"a path aware network should aim to not perform worse than the default case most of the time\" or something similar.",
              "createdAt": "2019-03-07T16:52:53Z",
              "updatedAt": "2019-03-08T13:17:18Z"
            },
            {
              "originalPosition": 29,
              "body": "Please change \"retrieving a webpage\" to \"retrieving a small webpage\" or maybe \"a small file\". In my current evaluation I have many large web pages (which is apparently the default nowadays), and when using only a single path, my low latency path usually performs worse than my high capacity path because there's just sooo many large files in a single web page. ;)\r\n\r\nAlso, I'm not sure this already covers the \"trade-offs\" bit -- Maybe it makes sense to further add something like: \r\n\"Additionally, there may be trade-offs between path properties, e.g., latency and data rate, and path elements may influence these trade-offs with their choices.\"\r\n\r\nEditorial comments:\r\nHere maybe change passive to active, i.e., \"paths with different properties are preferred\" --> \"an entity may prefer paths with different properties\".\r\nAnd please add an \"or\" before the second \"retrieving\".",
              "createdAt": "2019-03-07T16:59:03Z",
              "updatedAt": "2019-03-08T13:17:18Z"
            },
            {
              "originalPosition": 33,
              "body": "This still reads a bit confusing to me, because we have \"the current state of the network\" and \"packets sent now\", which sounds like we are talking about the same point in time.\r\nSuggestion: \"[\u2026] as path properties that were recently measured may have become outdated and, thus, useless to predict the path properties of packets sent now.\"",
              "createdAt": "2019-03-07T17:03:52Z",
              "updatedAt": "2019-03-08T13:17:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExOTIxODg0",
          "commit": {
            "abbreviatedOid": "5370838"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-07T17:36:06Z",
          "updatedAt": "2019-03-07T17:36:06Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Agreed & changed.",
              "createdAt": "2019-03-07T17:36:06Z",
              "updatedAt": "2019-03-08T13:17:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExOTI1MzU2",
          "commit": {
            "abbreviatedOid": "5370838"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-07T17:43:07Z",
          "updatedAt": "2019-03-07T17:43:07Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Yes, that sounds better & is more general.",
              "createdAt": "2019-03-07T17:43:07Z",
              "updatedAt": "2019-03-08T13:17:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExOTM1NzM5",
          "commit": {
            "abbreviatedOid": "5370838"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-07T18:04:30Z",
          "updatedAt": "2019-03-07T18:04:31Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "You are right, this property is not achievable in some cases.\r\nWhat about this sentence?\r\n\r\nAs the possible benefits of a well chosen path varies based on the goal, as a baseline, a path selection algorithm should aim to not perform worse than the default case most of the time.",
              "createdAt": "2019-03-07T18:04:30Z",
              "updatedAt": "2019-03-08T13:17:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExOTQxOTgz",
          "commit": {
            "abbreviatedOid": "5370838"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-07T18:17:48Z",
          "updatedAt": "2019-03-07T18:17:49Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Did you mean \"Additionally, there may be trade-offs between path properties, e.g., latency and data rate, and ~~path elements~~ **entities** may influence these trade-offs with their choices.\"?\r\n\r\nOr am I misunderstanding what is meant by trade-offs?\r\nMy understanding is: Entity selecting optimal path w.r.t. property A may need to make compromises on property B.",
              "createdAt": "2019-03-07T18:17:49Z",
              "updatedAt": "2019-03-08T13:17:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExOTQ0MTY5",
          "commit": {
            "abbreviatedOid": "5370838"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-07T18:22:19Z",
          "updatedAt": "2019-03-07T18:22:19Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Changed sentence to:\r\n[...], as path properties that were previously measured may have become outdated and thus useless to predict the path properties of packets sent now.",
              "createdAt": "2019-03-07T18:22:19Z",
              "updatedAt": "2019-03-08T13:17:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyMjgyNjM4",
          "commit": {
            "abbreviatedOid": "e172e5f"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-08T13:35:18Z",
          "updatedAt": "2019-03-08T13:35:18Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Yep, sounds good.",
              "createdAt": "2019-03-08T13:35:18Z",
              "updatedAt": "2019-03-08T13:35:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyMjgzOTg3",
          "commit": {
            "abbreviatedOid": "e172e5f"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-08T13:39:06Z",
          "updatedAt": "2019-03-08T13:39:06Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I meant that, for example, if I choose a path because it's low latency and then transmit a lot of data over it, it might no longer be low latency.\r\nAlso I'm thinking about what Gorry said at the IETF 103 session: On the \"Dynamic properties\" slide, he commented that \"you can trade any of these properties for another\", and something about modems. To be honest, I'm not sure I fully understand what he was saying and why you can trade all these properties for each other... but that's where I'm trying to go.\r\nAs it's not entirely clear, I'm okay with leaving it out for now and see if we get a better understanding of these trade-offs.",
              "createdAt": "2019-03-08T13:39:06Z",
              "updatedAt": "2019-03-08T13:39:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyMjg0MzQz",
          "commit": {
            "abbreviatedOid": "e172e5f"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-08T13:40:02Z",
          "updatedAt": "2019-03-08T13:40:03Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Yes, that works! My professor is very strict about always putting commas around the \"thus\", but I guess we don't have to be so strict here ;)",
              "createdAt": "2019-03-08T13:40:02Z",
              "updatedAt": "2019-03-08T13:40:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyMjg2Mzgx",
          "commit": {
            "abbreviatedOid": "e172e5f"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks, looks good to me now.\r\nI'm curious to find out what the Research Group thinks.",
          "createdAt": "2019-03-08T13:45:27Z",
          "updatedAt": "2019-03-08T13:45:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 8,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU5MjEwNDEz",
      "title": "Redefine domain, backbone, and dynamic properties",
      "url": "https://github.com/panrg/path-properties/pull/8",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I went over our property and category definitions and adjusted them to our new terminology.\r\nIn the process, PvDs went out of the draft, because they are related to how to get domain properties, not what domain properties exist. But maybe if we find we are missing PvD, we can add it again later.\r\n\r\nAlso, I realized that several properties relate to both path elements in the same domain and in the backbone. Overall, these categories are quite endpoint-centric, and maybe we want to rethink them at some point - not now though. ;)",
      "createdAt": "2019-03-07T17:49:24Z",
      "updatedAt": "2019-10-22T15:39:05Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "8c45670fe752cf107e142ba00e754bae5d84d7e0",
      "headRepository": "panrg/path-properties",
      "headRefName": "domain-backbone-dynamic-property-definitions",
      "headRefOid": "fd9264284ee52c7d7c186d34bdddc4f8f44c8f96",
      "closedAt": "2019-03-11T17:41:53Z",
      "mergedAt": "2019-03-11T17:41:53Z",
      "mergedBy": "theri",
      "mergeCommit": {
        "oid": "6f2d2bf27f41c2157f6c0608f2825b519309b02b"
      },
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "Maybe the easiest solution regarding the definition of \"Domain\" is to not provide a separate definition in the Terminology section, and just keep the definition of \"within the first few hops\", as it is given now in the \"Domain Property\" section. At least for the submission tomorrow, and then we can ask the group if they have an idea how to clearly define it.",
          "createdAt": "2019-03-10T13:42:38Z",
          "updatedAt": "2019-03-10T13:42:38Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the fixes!\r\nI also changed the second \"administrative domain\" to just \"domain\", because I think the sentence applied to domains in general.\r\nNow we have \"administrative\" only to explain that \"Domain properties [\u2026] are usually in the same administrative domain as an endpoint considering them.\", and when explicitly talking about an \"administrative entity\" in the corresponding property.\r\n\r\nAlso, I changed \"set of path elements\" to \"path segment\" because we have a definition for that now.\r\n\r\nIs this ready to merge?",
          "createdAt": "2019-03-11T11:22:18Z",
          "updatedAt": "2019-03-11T11:22:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyMjI1ODk1",
          "commit": {
            "abbreviatedOid": "82af81c"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Main point is the definition of Domain/backbone properties.\r\nAnd some textual changes.",
          "createdAt": "2019-03-08T10:33:26Z",
          "updatedAt": "2019-03-08T11:31:37Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Do we really want to say Domain properties = properties of path elements within same AS? Since e.g., if we look at the machine in my office, which is connected to the ETH network. The corresponding AS is \"SWITCH\", which is an AS for all swiss universities, and I would not consider a device in a university in Geneva as part of my domain.\r\n\r\nI would rather define it as:\r\n\"Domain path properties relate to path elements within the first hop or the first few hops, which are usually in the same administrative domain as an endpoint considering them.\"",
              "createdAt": "2019-03-08T10:33:26Z",
              "updatedAt": "2019-03-11T11:18:26Z"
            },
            {
              "originalPosition": 17,
              "body": "Small textual change, same reasoning as above:\r\n\"Due to the potential physical proximity and pre-existing trust or contractual relationships between endpoints and path elements within the same administrative domain, domain properties may be more accessible to the endpoint than other properties.\"",
              "createdAt": "2019-03-08T10:37:10Z",
              "updatedAt": "2019-03-11T11:18:26Z"
            },
            {
              "originalPosition": 25,
              "body": "Small textual changes:\r\n\"For example, a user might select between multiple potential adjacent path elements by selecting between multiple available WiFi Access Points.\r\nOr when connected to an Access Point, the user may move closer to enable their device to use a different access technology, potentially increasing the data rate available to the device.\"",
              "createdAt": "2019-03-08T10:44:32Z",
              "updatedAt": "2019-03-11T11:18:26Z"
            },
            {
              "originalPosition": 32,
              "body": "Do we want so specify the access technology as a property for all properties or only domain properties?\r\n\r\nIn the former case, we should probably add a sentence similar to the \"Presence of certain network function on the path\":\r\n\"This path element may be either in the same administrative domain as the endpoint or in a different administrative domain, i.e., the backbone.\"\r\nOr just add a disclaimer to the beginning of this section, saying that in some cases these properties can also relate to path elements in the backbone.\r\n\r\nIn the latter case, I would change the first sentence to:\r\n\"The physical or link layer technology used on one or multiple domain path elements for transmitting a flow.\"\r\nBut then we should probably also define \"domain path element\" in the beginning of this section.",
              "createdAt": "2019-03-08T10:57:53Z",
              "updatedAt": "2019-03-11T11:18:26Z"
            },
            {
              "originalPosition": 47,
              "body": "I would change this sentence to conform with the modified Domain property definition:\r\n\"Backbone path properties relate to path elements that are not within the endpoint's domain, and thus in the backbone from the endpoint's point of view.\"",
              "createdAt": "2019-03-08T11:01:08Z",
              "updatedAt": "2019-03-11T11:18:26Z"
            },
            {
              "originalPosition": 51,
              "body": "I would change ~~easily available~~ to **accessible**\r\n",
              "createdAt": "2019-03-08T11:02:40Z",
              "updatedAt": "2019-03-11T11:18:26Z"
            },
            {
              "originalPosition": 59,
              "body": "Some path properties relate to the entire path, part of which often lies outside of an endpoint's ~~administrative~~ domain. Thus, such properties are listed as Backbone Properties.",
              "createdAt": "2019-03-08T11:04:56Z",
              "updatedAt": "2019-03-11T11:18:26Z"
            },
            {
              "originalPosition": 67,
              "body": "I would extend the description of disjointness a bit:\r\n\r\n\"For a set of two paths, the number of shared path elements can be a measure of intersection (e.g., Jaccard coefficient, which is the number of shared elements divided by the total number of elements), and conversely, the number of non-shared path elements can be a measure of disjointness (e.g., 1 - Jaccard coefficient).\r\nA multipath protocol might use disjointness of paths as a metric to reduce the number of single points of failure.\"",
              "createdAt": "2019-03-08T11:25:37Z",
              "updatedAt": "2019-03-11T11:18:26Z"
            },
            {
              "originalPosition": 87,
              "body": "I would use the previously defined path segment ;)\r\n\"Dynamic path properties relate to a path segment with respect to the transmission of an individual packet or flow over this path segment.\"\r\n\r\nMaybe we should define path segment in the terminology section?",
              "createdAt": "2019-03-08T11:28:52Z",
              "updatedAt": "2019-03-11T11:18:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyMjg3NTkz",
          "commit": {
            "abbreviatedOid": "82af81c"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-08T13:48:38Z",
          "updatedAt": "2019-03-08T13:48:39Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I wanted a clear definition, but you're right, \"domain\" is not necessarily \"AS\". \r\nCan we drop the \"usually\" and just say that it's the same administrative domain? In your example, that administrative domain would be ETH, not \"SWITCH\", I'd say. But now I'm wondering if there's a formal definition for administrative domain...",
              "createdAt": "2019-03-08T13:48:38Z",
              "updatedAt": "2019-03-11T11:18:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyMzE5OTMw",
          "commit": {
            "abbreviatedOid": "82af81c"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-08T15:00:26Z",
          "updatedAt": "2019-03-08T15:00:26Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I wanted a clear definition, but you're right, \"domain\" is not necessarily \"AS\". \r\nNow I'm wondering if there's a formal definition for administrative domain...",
              "createdAt": "2019-03-08T15:00:26Z",
              "updatedAt": "2019-03-11T11:18:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyMzE5OTU3",
          "commit": {
            "abbreviatedOid": "82af81c"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-08T15:00:29Z",
          "updatedAt": "2019-03-08T15:00:30Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Okay, sounds good.",
              "createdAt": "2019-03-08T15:00:29Z",
              "updatedAt": "2019-03-11T11:18:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyMzIwMDAx",
          "commit": {
            "abbreviatedOid": "82af81c"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-08T15:00:34Z",
          "updatedAt": "2019-03-08T15:00:34Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Agreed, thanks!",
              "createdAt": "2019-03-08T15:00:34Z",
              "updatedAt": "2019-03-11T11:18:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyMzIwMDI5",
          "commit": {
            "abbreviatedOid": "82af81c"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-08T15:00:37Z",
          "updatedAt": "2019-03-08T15:00:37Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I think for an endpoint this only makes sense within the same domain, as the endpoint might be able to influence that technology. In the backbone, the endpoint doesn't care if some link is 1G or 10G Ethernet, if there's Fiber involved or not, etc., does it? At most it cares about congestion on this link and the resulting latency or data rate bottleneck. \r\n\r\nThen I guess I'll change first sentence of the definition to only include path elements in the same domain. I don't think that we need to add a further definition to this section, but perhaps we need a definition for \"domain\" in our Terminology section.",
              "createdAt": "2019-03-08T15:00:37Z",
              "updatedAt": "2019-03-11T11:18:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyMzIwMDY1",
          "commit": {
            "abbreviatedOid": "82af81c"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-08T15:00:41Z",
          "updatedAt": "2019-03-08T15:00:41Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Well, I don't say AS here, but I can change \"within a different administrative domain\" to \"not within the same domain\", then it's more clearly separated from domain properties.",
              "createdAt": "2019-03-08T15:00:41Z",
              "updatedAt": "2019-03-11T11:18:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyMzIwMDc5",
          "commit": {
            "abbreviatedOid": "82af81c"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-08T15:00:42Z",
          "updatedAt": "2019-03-08T15:00:43Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Fine with me.",
              "createdAt": "2019-03-08T15:00:42Z",
              "updatedAt": "2019-03-11T11:18:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyMzIwMTA3",
          "commit": {
            "abbreviatedOid": "82af81c"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-08T15:00:46Z",
          "updatedAt": "2019-03-08T15:00:46Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Agreed.\r\n\r\nNow I realize that moving the network functions from the Backbone properties to the domain properties was probably a mistake, as this property also relates to the entire path. So I will put them back in the Backbone Properties section.",
              "createdAt": "2019-03-08T15:00:46Z",
              "updatedAt": "2019-03-11T11:18:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyMzIwMTUw",
          "commit": {
            "abbreviatedOid": "82af81c"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-08T15:00:49Z",
          "updatedAt": "2019-03-08T15:00:50Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "Nice. I didn't know about this and it seems pretty useful. Thanks!",
              "createdAt": "2019-03-08T15:00:49Z",
              "updatedAt": "2019-03-11T11:18:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyMzIxMDM5",
          "commit": {
            "abbreviatedOid": "82af81c"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-08T15:02:39Z",
          "updatedAt": "2019-03-08T15:02:39Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Yes, we definitely should!\r\n\r\nAs the terminology section is merged now, I'm merging it into this branch and then adding the missing definitions.",
              "createdAt": "2019-03-08T15:02:39Z",
              "updatedAt": "2019-03-11T11:18:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyMzI5MjIw",
          "commit": {
            "abbreviatedOid": "82af81c"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-08T15:19:14Z",
          "updatedAt": "2019-03-08T15:19:14Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Oh, and I just realized that as is, a path segment is the same as a path. But a path should be defined end-to-end, right? So I'm adding \"between two endpoints\" to the path definition.",
              "createdAt": "2019-03-08T15:19:14Z",
              "updatedAt": "2019-03-11T11:18:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyMzM3MDY1",
          "commit": {
            "abbreviatedOid": "82af81c"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks for the feedback and suggestions, I think I got them all.\r\nIn the process I added \"path segment\" and \"domain\" to the Terminology section, though I'm not sure if the definition of \"domain\" is precise enough yet. But we'll figure it out. :)",
          "createdAt": "2019-03-08T15:35:05Z",
          "updatedAt": "2019-03-08T15:35:05Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNjAyODA4",
          "commit": {
            "abbreviatedOid": "871bdf6"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-10T13:31:32Z",
          "updatedAt": "2019-03-10T13:31:32Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I had the same thoughts when I looked at our definitions. Administrative Domain is defined in RFC1136 and the relation to an AS is: an administrative domain consisting of a single routing domain is analogous to an AS.\r\nBut an AS cannot span multiple administrative domains, which means our local network (which is an example of our definition of domain) cannot be an administrative domain.",
              "createdAt": "2019-03-10T13:31:32Z",
              "updatedAt": "2019-03-11T11:18:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNjAyOTc1",
          "commit": {
            "abbreviatedOid": "871bdf6"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-10T13:34:56Z",
          "updatedAt": "2019-03-10T13:34:56Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "That's true.\r\n\r\nI'm not sure if our definition of domain in the Terminology section is not confusing since we mention both administrative control and administrative domain which do not relate to the same concept.",
              "createdAt": "2019-03-10T13:34:56Z",
              "updatedAt": "2019-03-11T11:18:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNjAzMTM1",
          "commit": {
            "abbreviatedOid": "871bdf6"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-10T13:38:15Z",
          "updatedAt": "2019-03-10T13:38:16Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Yes that sounds good",
              "createdAt": "2019-03-10T13:38:15Z",
              "updatedAt": "2019-03-11T11:18:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNjE2MTEx",
          "commit": {
            "abbreviatedOid": "871bdf6"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-10T18:47:16Z",
          "updatedAt": "2019-03-10T18:47:17Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I see, thanks for looking it up.\r\nEven though it's defined like this elsewhere, I think we could still have a different definition in our draft. But I'll remove the definition from the Terminology section for now, as it's not clear enough and maybe confusing. Hopefully we can find a better definition, maybe with a little help from the Research Group.",
              "createdAt": "2019-03-10T18:47:17Z",
              "updatedAt": "2019-03-11T11:18:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNzQ5NjUz",
          "commit": {
            "abbreviatedOid": "82ddbc8"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Minor textual fixes.",
          "createdAt": "2019-03-11T10:13:55Z",
          "updatedAt": "2019-03-11T10:27:02Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "The physical or link layer technology used for transmitting or receiving a flow on one or multiple path elements in the same domain.",
              "createdAt": "2019-03-11T10:13:55Z",
              "updatedAt": "2019-03-11T11:18:26Z"
            },
            {
              "originalPosition": 57,
              "body": "Backbone path properties relate to path elements not within the same domain as an endpoint considering them, thus, in the backbone from the endpoint's point of view.",
              "createdAt": "2019-03-11T10:15:13Z",
              "updatedAt": "2019-03-11T11:18:26Z"
            },
            {
              "originalPosition": 102,
              "body": "Properties related to a path element which constitute a single layer 2 domain are abstracted from the used physical and link layer technology, similar to {{RFC8175}}.",
              "createdAt": "2019-03-11T10:23:37Z",
              "updatedAt": "2019-03-11T11:18:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNzc0MjMy",
          "commit": {
            "abbreviatedOid": "82ddbc8"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T11:08:39Z",
          "updatedAt": "2019-03-11T11:08:39Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Yep, fixed.",
              "createdAt": "2019-03-11T11:08:39Z",
              "updatedAt": "2019-03-11T11:18:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNzc0NDYy",
          "commit": {
            "abbreviatedOid": "82ddbc8"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T11:09:14Z",
          "updatedAt": "2019-03-11T11:09:14Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "Fixed.",
              "createdAt": "2019-03-11T11:09:14Z",
              "updatedAt": "2019-03-11T11:18:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNzc0Njk5",
          "commit": {
            "abbreviatedOid": "82ddbc8"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-11T11:09:48Z",
          "updatedAt": "2019-03-11T11:09:48Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "Fixed.",
              "createdAt": "2019-03-11T11:09:48Z",
              "updatedAt": "2019-03-11T11:18:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyOTgxNDAx",
          "commit": {
            "abbreviatedOid": "fd92642"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-11T17:33:31Z",
          "updatedAt": "2019-03-11T17:33:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 9,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU5MjEyMDY1",
      "title": "Security considerations, acknowledgements",
      "url": "https://github.com/panrg/path-properties/pull/9",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "After redefining the properties, I went over our security considerations section and made it a bit less informal and fuzzy.\r\nAlso, I added a sentence to acknowledge PANRG - do we want to name specific people there? We got some comments and notes from Adrian Perrig, for example.\r\n\r\n(And sorry for opening these PRs before the others are merged, but tomorrow is a holiday here, so I won't have access to my work computer. If we get any merge conflicts, I will resolve them on my private computer. ;) )",
      "createdAt": "2019-03-07T17:54:27Z",
      "updatedAt": "2019-10-22T15:38:53Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "f56fe0c088f5a36397f6b77567c7e585f9595d8d",
      "headRepository": "panrg/path-properties",
      "headRefName": "security-considerations-1",
      "headRefOid": "29a5142303752cc49787c553c9ad0567c6fcb394",
      "closedAt": "2019-03-11T13:26:41Z",
      "mergedAt": "2019-03-11T13:26:41Z",
      "mergedBy": "theri",
      "mergeCommit": {
        "oid": "3b14751c55898859f1775958b0deb5a40f41901c"
      },
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "I like the new security definitions.\r\nYeah, maybe we can add another sentence: \"Thanks to Adrian Perrig for feedback.\"",
          "createdAt": "2019-03-10T13:45:27Z",
          "updatedAt": "2019-03-10T13:45:27Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Done.\r\nI will give this and #8 another look tomorrow and merge, then submit the revision.",
          "createdAt": "2019-03-10T18:52:31Z",
          "updatedAt": "2019-03-10T18:52:31Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 10,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU5OTEyMzk1",
      "title": "Abstract fix",
      "url": "https://github.com/panrg/path-properties/pull/10",
      "state": "MERGED",
      "author": "cyrill-k",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Generalized abstract",
      "createdAt": "2019-03-11T10:36:14Z",
      "updatedAt": "2019-10-22T15:38:55Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "2edc302b777af2fc1709f469545984134209c97e",
      "headRepository": "panrg/path-properties",
      "headRefName": "abstract",
      "headRefOid": "2fed3e1ad65b86b6cbf07fc524303d684289f095",
      "closedAt": "2019-03-11T11:23:40Z",
      "mergedAt": "2019-03-11T11:23:40Z",
      "mergedBy": "theri",
      "mergeCommit": {
        "oid": "452692f7c83366f94e708f3a8f3977bf516b47cb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNzc5OTQy",
          "commit": {
            "abbreviatedOid": "2fed3e1"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Yes, this should be more general.",
          "createdAt": "2019-03-11T11:23:32Z",
          "updatedAt": "2019-03-11T11:23:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 11,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkzMTE0NTE4",
      "title": "Fix terminology",
      "url": "https://github.com/panrg/path-properties/pull/11",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Changed definitions according to the suggestions in #1.\r\n\r\nQuestions:\r\n- With this, a path is always between two hosts, but a subpath can be between a host and a node. I think this makes sense, as we are talking about \"endpoints\" (hosts) a lot. Do you agree?\r\n- Is the part about the layering clear enough? I think a single path ultimately consists of just one sequence of path elements, just that some lower-layer path elements are hidden when you, e.g., only look at the transport layer. I'm not sure if \"A path is defined on a specific layer\" actually conveys this. Ideas? Opinions?",
      "createdAt": "2019-06-30T16:00:16Z",
      "updatedAt": "2019-07-04T16:39:12Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "6f2d2bf27f41c2157f6c0608f2825b519309b02b",
      "headRepository": "panrg/path-properties",
      "headRefName": "fix-terminology",
      "headRefOid": "c5413fd481e35de6916b3887fceae2d48b0db14e",
      "closedAt": "2019-07-04T16:39:00Z",
      "mergedAt": "2019-07-04T16:39:00Z",
      "mergedBy": "theri",
      "mergeCommit": {
        "oid": "070a50b2b75108ebcfa0964eda3b4c47b79ffe06"
      },
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "> Changed definitions according to the suggestions in #1.\r\n> \r\n> Questions:\r\n> \r\n>     * With this, a path is always between two hosts, but a subpath can be between a host and a node. I think this makes sense, as we are talking about \"endpoints\" (hosts) a lot. Do you agree?\r\n\r\nYes, I think it might be a good idea to more clearly separate paths and subpaths.\r\n\r\n>     * Is the part about the layering clear enough? I think a single path ultimately consists of just one sequence of path elements, just that some lower-layer path elements are hidden when you, e.g., only look at the transport layer. I'm not sure if \"A path is defined on a specific layer\" actually conveys this. Ideas? Opinions?\r\n\r\nMaybe instead of saying:\r\nA path is defined on a specific layer.\r\n\r\nWe could say:\r\nA path can be viewed as an abstraction on a specific layer, omitting lower layer path elements.",
          "createdAt": "2019-07-03T09:37:22Z",
          "updatedAt": "2019-07-03T09:37:22Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the feedback and suggestions!\r\n\r\nThe node definition now talks about \"processing\" packets, but then gives a few examples. I'm still wondering if we need the \"implements a function which\" at all.\r\n\r\nI like your proposal about the layering and I put everything layering-related into a single definition (the path) instead of having it spread across multiple definitions. \r\n\r\nAlso, a property is now defined on one or a sequence of path elements - maybe we can allow a sequence of length 1 and simplify our definition accordingly? But that would confuse me if we didn't make it explicit, so I left it like it is now.\r\n\r\nWhat do you think?",
          "createdAt": "2019-07-03T13:06:29Z",
          "updatedAt": "2019-07-03T13:06:29Z"
        },
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "\r\n> The node definition now talks about \"processing\" packets, but then gives a few examples. I'm still wondering if we need the \"implements a function which\" at all.\r\n\r\nI simplified it to:\r\nAn entity which processes packets, e.g., sends, receives, forwards, or modifies them.\r\n\r\n> I like your proposal about the layering and I put everything layering-related into a single definition (the path) instead of having it spread across multiple definitions.\r\n\r\nThe definitions looks cleaner now. I removed \"Paths can be traversed by packets\".\r\n\r\n> Also, a property is now defined on one or a sequence of path elements - maybe we can allow a sequence of length 1 and simplify our definition accordingly? But that would confuse me if we didn't make it explicit, so I left it like it is now.\r\n> \r\n> What do you think?\r\n\r\nI would also leave it as it is.\r\n\r\n",
          "createdAt": "2019-07-03T15:08:55Z",
          "updatedAt": "2019-07-03T15:08:55Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the changes!\r\nI just got feedback that \"directly adjacent\" can be reduced to \"adjacent\", which I changed in the draft.\r\nOtherwise, I think this is good to go.",
          "createdAt": "2019-07-04T06:29:52Z",
          "updatedAt": "2019-07-04T06:29:52Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3MzU5MzMx",
          "commit": {
            "abbreviatedOid": "c01fb3e"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-07-03T09:16:44Z",
          "updatedAt": "2019-07-03T09:22:51Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I would refrain from defining a node as a device since in the case of network service chaining, each service would be considered a node, which means they would run on the same device.\r\n\r\nMaybe we could replace \"device\" with \"entity\".\r\n\r\nAnother point that may be problematic is the restriction on a (single) specific layer, since some protocols might not clearly be part of a single layer (e.g., ICMP which is a layer 3 protocol but looks like a layer 4 protocol...). Should we maybe simply define a node as: \"An entity that implements a function that takes packet(s) as inputs and outputs packet(s)\" or is this too abstract?",
              "createdAt": "2019-07-03T09:16:45Z",
              "updatedAt": "2019-07-04T06:28:31Z"
            },
            {
              "originalPosition": 14,
              "body": "I would rephrase the second sentence:\r\n\r\nIf this router does not implement transport layer functionality, it is hidden when a higher layer, such as the transport or application layer, is considered.",
              "createdAt": "2019-07-03T09:19:12Z",
              "updatedAt": "2019-07-04T06:28:31Z"
            },
            {
              "originalPosition": 30,
              "body": "Maybe we should define a property on a sequence of path elements, since if we talk about one way latency between two nodes A and B, the order of the nodes changes the meaning of the property.",
              "createdAt": "2019-07-03T09:22:29Z",
              "updatedAt": "2019-07-04T06:28:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NDU1Njk4",
          "commit": {
            "abbreviatedOid": "c01fb3e"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T12:36:29Z",
          "updatedAt": "2019-07-03T12:36:30Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Agree that defining a node as a device is a problem. Similar to links, nodes should not be limited to physical entities.\r\nAbout the layering, yes. Maybe all this layering complexity in our definitions is unnecessary anyway and we should get rid of it? I think there was a reason to introduce the layering in the first place, but I forgot.\r\n\r\nIn your proposed definition, you replace \"protocol\" with a \"function\", I think that's a good idea - not every node may implement a protocol in the traditional way (e.g., does a firewall implement a protocol if it filters based on headers of this protocol? I wouldn't say so.).\r\nHowever, \"input and output\" sounds to me like a node necessarily transforms packets, but it may only send or only receive packets.\r\nSo how about \"An entity that implements a function which sends, receives, or forwards packets\"?\r\nOr maybe even just \"An entity that sends, receives, or forwards packets\"? Because that's what makes the node different from the link, right?\r\nOriginally, I wrote \"handles packets\", but then I wanted to be more specific. However, now I'm not sure if \"sends, receives, or forwards\" actually covers everything, because it doesn't explicitly say that the node may also modify the packet...",
              "createdAt": "2019-07-03T12:36:30Z",
              "updatedAt": "2019-07-04T06:28:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NDU4MzM3",
          "commit": {
            "abbreviatedOid": "c01fb3e"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T12:41:18Z",
          "updatedAt": "2019-07-03T12:41:18Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Agreed, if we keep the layering at all -- I'm not too happy with the whole \"when considering the XYZ layer\", but I think the concept of \"considering a path on XYZ layer\" is better than defining a separate path for each layer.",
              "createdAt": "2019-07-03T12:41:18Z",
              "updatedAt": "2019-07-04T06:28:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NDU5Njc5",
          "commit": {
            "abbreviatedOid": "c01fb3e"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T12:43:49Z",
          "updatedAt": "2019-07-03T12:43:50Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Agreed.\r\nI wanted to be able to define a property of, e.g., just some nodes but not the links between them, but I'm not sure if we actually need this, and if we do, I think we can work with it anyway.",
              "createdAt": "2019-07-03T12:43:49Z",
              "updatedAt": "2019-07-04T06:28:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NDY1Mjgy",
          "commit": {
            "abbreviatedOid": "c01fb3e"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T12:53:59Z",
          "updatedAt": "2019-07-03T12:54:00Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "We could say:\r\nAn entity that can receive packets from an incoming link and can send arbitrary packets on an outgoing link.\r\n\r\nDoes this imply that nodes process packets only in one direction? Or is it clear?",
              "createdAt": "2019-07-03T12:53:59Z",
              "updatedAt": "2019-07-04T06:28:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NDY4MTYx",
          "commit": {
            "abbreviatedOid": "c01fb3e"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T12:58:56Z",
          "updatedAt": "2019-07-03T12:58:57Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "We can also define it as: \"... containing the sequence or set of path elements\", but this makes the concept more complex which is probably not a good idea.\r\n\r\nSince we define it as a \"sequence of path elements\" and not \"sequence of path elements alternating between links and nodes\", we can still define a property for some nodes (they would just be ordered).",
              "createdAt": "2019-07-03T12:58:56Z",
              "updatedAt": "2019-07-04T06:28:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NDczOTUy",
          "commit": {
            "abbreviatedOid": "93ac0ea"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T13:09:18Z",
          "updatedAt": "2019-07-03T13:09:19Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Phew, tricky. :D Yes, I think sequence is fine. If we must have the set, we can have it as a set of single properties, each of which is defined for a specific path element.",
              "createdAt": "2019-07-03T13:09:18Z",
              "updatedAt": "2019-07-04T06:28:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3NDc0NTYz",
          "commit": {
            "abbreviatedOid": "93ac0ea"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T13:10:28Z",
          "updatedAt": "2019-07-03T13:10:29Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I went with a more open definition and just say \"process\" now. What do you think?",
              "createdAt": "2019-07-03T13:10:28Z",
              "updatedAt": "2019-07-04T06:28:31Z"
            }
          ]
        }
      ]
    },
    {
      "number": 12,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0NjQ3ODEx",
      "title": "Some terms fixed in other sections",
      "url": "https://github.com/panrg/path-properties/pull/12",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Now that we've converged on the terminology, I did a first pass on the other sections, see the \"adjust-terms\" branch. \r\nMostly, I replaced \"endpoint\" with \"host\" and \"path segment\" with \"subpath\". Sometimes I made \"path element\" more specific, i.e., link or node.\r\nI think these are the minimal changes. Feel free to add more.",
      "createdAt": "2019-07-04T16:59:26Z",
      "updatedAt": "2019-10-22T15:39:11Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "070a50b2b75108ebcfa0964eda3b4c47b79ffe06",
      "headRepository": "panrg/path-properties",
      "headRefName": "adjust-terms",
      "headRefOid": "1de3aa5d441188f41fdca868a85a8a95631b5446",
      "closedAt": "2019-07-08T11:02:47Z",
      "mergedAt": "2019-07-08T11:02:46Z",
      "mergedBy": "theri",
      "mergeCommit": {
        "oid": "168c5a4a7cbaf0a4707f057dc413f478a6c434f3"
      },
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "It looks already good. I only made a small change for the network function, since I think a network function should always be performed by a node.",
          "createdAt": "2019-07-08T10:28:20Z",
          "updatedAt": "2019-07-08T10:28:20Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "You're absolutely right, thanks for the fix!\r\nIf there's no further changes, I'll merge this and submit the draft within the next few hours.",
          "createdAt": "2019-07-08T10:57:04Z",
          "updatedAt": "2019-07-08T10:57:04Z"
        },
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "That's fine, thanks for submitting!",
          "createdAt": "2019-07-08T11:02:13Z",
          "updatedAt": "2019-07-08T11:02:13Z"
        },
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry, I should have merged and not closed ;)",
          "createdAt": "2019-07-08T11:03:25Z",
          "updatedAt": "2019-07-08T11:03:25Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "No worries ;)",
          "createdAt": "2019-07-08T11:03:57Z",
          "updatedAt": "2019-07-08T11:03:57Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 18,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMxMDU5ODkz",
      "title": "Rephrase abstract",
      "url": "https://github.com/panrg/path-properties/pull/18",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Tweaking the abstract phrasing to address Med's comments, see issue #13, I ended up completely rephrasing it.\r\nI think the abstract now includes everything important - what are path properties, what is our context, what does this document do. Also, it's all in active voice now, which should be easier to parse.\r\n\r\nDoes this phrasing work for you, Cyrill?",
      "createdAt": "2019-10-22T15:31:45Z",
      "updatedAt": "2019-10-24T08:26:53Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "168c5a4a7cbaf0a4707f057dc413f478a6c434f3",
      "headRepository": "panrg/path-properties",
      "headRefName": "rephrase-abstract",
      "headRefOid": "e7eac64c7d19a575fd1a43d3f35bc9dd9dd48533",
      "closedAt": "2019-10-24T08:26:52Z",
      "mergedAt": "2019-10-24T08:26:52Z",
      "mergedBy": "cyrill-k",
      "mergeCommit": {
        "oid": "85b8781e2862f7b1d3fc39eac832fd459c6c696c"
      },
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "I like this this rephrasing since it addresses all of Med's comments and avoids the confusion about broadcast/multicast vs unicast.",
          "createdAt": "2019-10-24T08:26:37Z",
          "updatedAt": "2019-10-24T08:26:37Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 19,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMxMDYyODI5",
      "title": "adjusted dynamic path properties to IPPM terminology",
      "url": "https://github.com/panrg/path-properties/pull/19",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Just merging this using a PR because it feels cleaner than doing it on the command line ;)",
      "createdAt": "2019-10-22T15:37:38Z",
      "updatedAt": "2019-10-22T15:37:46Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "168c5a4a7cbaf0a4707f057dc413f478a6c434f3",
      "headRepository": "panrg/path-properties",
      "headRefName": "ietf106",
      "headRefOid": "15a84c4abca9ebfa44eb625763d66cd450bdcc1c",
      "closedAt": "2019-10-22T15:37:46Z",
      "mergedAt": "2019-10-22T15:37:46Z",
      "mergedBy": "theri",
      "mergeCommit": {
        "oid": "ffee44d10d8d7501504f61e9399ca728579ffd43"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 20,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMxMTIyNDQz",
      "title": "Rephrase and restructure introduction",
      "url": "https://github.com/panrg/path-properties/pull/20",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This addresses most comments in #14.\r\n\r\nAs a reference for architecture, we now refer to the questions draft, because that draft first what a path-aware network is.\r\nThen, our introduction now explains the structure of the draft: Terminology, classification of properties, then some examples of properties.\r\n\r\nFor the examples of properties, we have use cases to motivate them. As these use cases became rather long and were not really suitable to be bullet points anymore, I split them into subsections.\r\nAlso, I reshuffled them, so \"traffic policies\" became \"traffic configuration\", because that's really what our examples are doing. I wanted to make the distinction between path selection and traffic configuration clear - path selection decides between different paths through the network, and then when a path has been selected, we can configure this path, which is traffic configuration. Therefore, the firewall example moved to \"path selection\".\r\n\r\nOur old introduction contained a lot of text on classification of path properties. I kept this text, but moved it down after the terminology, because I think it fits better there.\r\nLater, we'll have to think more about this classification, e.g., the domain properties issue, but I'd say this is out of scope for this PR now. ;)\r\n\r\nWhat do you think?",
      "createdAt": "2019-10-22T17:55:50Z",
      "updatedAt": "2019-10-30T15:31:53Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "ffee44d10d8d7501504f61e9399ca728579ffd43",
      "headRepository": "panrg/path-properties",
      "headRefName": "introduction-changes",
      "headRefOid": "a5c89f765f3abadea3052c56f8b8b8498c615739",
      "closedAt": "2019-10-30T15:31:28Z",
      "mergedAt": "2019-10-30T15:31:28Z",
      "mergedBy": "theri",
      "mergeCommit": {
        "oid": "50c57596fc586b1e904d8f30560ff6d3b8ae2a02"
      },
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "I generally like the new structure more as it feels cleaner than before.\r\nMaybe we could consider moving the use case section after the terminology since we use expressions such as \"path\" in the use case section?\r\n\r\nOur use case section grew quite large which might be a bit of an issue since we do not want to give the impression that we provide an exhaustive list of possible use cases for path-aware networks.\r\nBut I think we should keep the text and ask during the next PANRG meeting what the audience thinks about this (it is easy to shorten these sections if necessary).\r\n\r\nRegarding the classification, I'm in favour of removing the classification into domain properties and backbone properties and simply have dynamic/non-dynamic properties.\r\nBut I agree that we should do this in another PR.",
          "createdAt": "2019-10-24T10:32:08Z",
          "updatedAt": "2019-10-24T10:32:08Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the review!\r\n\r\nI moved the use cases below the terminology section because I agree that this should be a separate section and it works much nicer with our structure this way.\r\nThe use cases section now includes the disclaimer that this is not an exhaustive list because new properties may become relevant, I think that sentence fits best here.\r\nI'll ask PANRG about the use case section at IETF 106 if we can get beyond the Terminology section. ;)",
          "createdAt": "2019-10-24T14:24:38Z",
          "updatedAt": "2019-10-24T14:24:38Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Merged this so I can base another PR on it -- Let's continue the discussion there.",
          "createdAt": "2019-10-30T15:31:53Z",
          "updatedAt": "2019-10-30T15:31:53Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 21,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMxNTk4Mjk3",
      "title": "Change definitions based on feedback",
      "url": "https://github.com/panrg/path-properties/pull/21",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR updates our terminology in line with feedback from IETF 105 and Med's comments.\r\nSee also issue #1.\r\n\r\nA node can now be an entire AS -- can a node also be something like an amorphous collection of path elements in case of partial visibililty? (open question)\r\n\r\nA property can now also apply to a set of subpaths -- I wanted this because the sequence of path elements on which a packet is sent can change frequently, even if the endpoints stay the same.\r\nDo you agree?",
      "createdAt": "2019-10-23T15:09:50Z",
      "updatedAt": "2019-11-01T14:30:21Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "ffee44d10d8d7501504f61e9399ca728579ffd43",
      "headRepository": "panrg/path-properties",
      "headRefName": "update-terminology",
      "headRefOid": "15964a38fd16cadc06a88f04add65487e0499420",
      "closedAt": "2019-11-01T14:30:20Z",
      "mergedAt": "2019-11-01T14:30:20Z",
      "mergedBy": "cyrill-k",
      "mergeCommit": {
        "oid": "dc949180e2651070da065e55358b189e59777a85"
      },
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "> A node can now be an entire AS -- can a node also be something like an amorphous collection of path elements in case of partial visibililty? (open question)\r\n\r\nI think defining an abstract node which can be a collection of entities is useful but then the question comes up if we even need links at all or if links are just abstract nodes that only forward packets?",
          "createdAt": "2019-10-24T10:19:35Z",
          "updatedAt": "2019-10-24T10:19:35Z"
        },
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "> About viewing a link as just another node that forwards packets, this sounds kind of confusing to me and I don't think I agree:\r\n> I think \"forward packets\" means different things for nodes and for links - nodes perform routing and switching, links connect one node to another. That's not the same thing, but we don't use \"forward\" for links in our definition, so we should be fine.\r\n\r\nI agree with you. It was just going through my head when I saw the definition of an abstract node. :)",
          "createdAt": "2019-10-30T16:50:32Z",
          "updatedAt": "2019-10-30T16:50:32Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for taking another look!\r\nSo it looks like we can merge this for now?",
          "createdAt": "2019-11-01T10:07:14Z",
          "updatedAt": "2019-11-01T10:07:14Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2NDM2OTkx",
          "commit": {
            "abbreviatedOid": "154e3e0"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I did some small textual changes and added some questions regarding the new terminology.",
          "createdAt": "2019-10-24T09:28:37Z",
          "updatedAt": "2019-10-24T09:31:11Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "I like the idea to change the path definition from \"alternating path elements\" to \"A sequence of adjacent path elements over which a packet can be transmitted\" since we address both comments on non-sensible paths (e.g., only links without nodes) and Med's comments on service function chaining.\r\n\r\nIs it okay to remove the multicast/broadcast remark from the path definition? It was only there for clarity or do we change how multicast/broadcast is defined?\r\n\r\nShould we add a sentence to indicate that we can look at paths using different abstraction levels (e.g., \"Also note that different entities might treat path elements at different levels of abstraction.\"). Although I think this should be clear from the new node definition...",
              "createdAt": "2019-10-24T09:28:37Z",
              "updatedAt": "2019-10-24T15:00:45Z"
            },
            {
              "originalPosition": 28,
              "body": "Do we still need subpath if we define path as being between two nodes (not hosts as before)?",
              "createdAt": "2019-10-24T09:29:01Z",
              "updatedAt": "2019-10-24T15:00:45Z"
            },
            {
              "originalPosition": 37,
              "body": "Did you change the Property definition (on one or multiple subpaths) to allow properties on links between multiple nodes (e.g., wireless links?) Or is there some other motivation?",
              "createdAt": "2019-10-24T09:30:04Z",
              "updatedAt": "2019-10-24T15:00:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2NDY0OTkz",
          "commit": {
            "abbreviatedOid": "154e3e0"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T10:14:46Z",
          "updatedAt": "2019-10-24T10:14:46Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Sorry I just now saw your comment on this pull request...\r\nI'm thinking that for properties between endpoints, we might need an abstract link analogous to the abstract node. Then we can model the (sub-)paths between endpoints as two nodes/hosts connected by the abstract link (e.g., 5-tuple).\r\nThis approach which associates a property with multiple (sub-)paths could work as well but might have the issue that it is not clear when the property held for which of the (sub-)paths.",
              "createdAt": "2019-10-24T10:14:46Z",
              "updatedAt": "2019-10-24T15:00:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2NjI0OTk2",
          "commit": {
            "abbreviatedOid": "154e3e0"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T14:35:31Z",
          "updatedAt": "2019-10-24T14:35:32Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "About multicast/broadcast: It was only there for clarity, but I think this should be explicitly stated somewhere. I wasn't sure it had to be in the path definition, so I took it out there and added it to my list of \"things to check before submitting\", so I was planning to add it somewhere else. However, on second thought, maybe the path definition is the best place to add it after all... I think I'll just re-add it to the definition for now. Maybe we'll find a better place for this kinds of clarifications later on - maybe we'll even add a figure? But that's future work.\r\n\r\nAbout the different abstraction levels, similarly, I think this should be somewhere. I'm not quite sure yet where, but I think this is related to partial visibility. The path definition already says \"an entity may have only partial visibility of the path elements that comprise a path\", so I'll just add something on the abstraction level there for now.",
              "createdAt": "2019-10-24T14:35:32Z",
              "updatedAt": "2019-10-24T15:00:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2NjMwODky",
          "commit": {
            "abbreviatedOid": "154e3e0"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T14:42:56Z",
          "updatedAt": "2019-10-24T14:42:57Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I think subpaths are still useful because I'd still use \"path\" as the end-to-end path between two hosts and \"subpath\" as just a part of this path.\r\nAlso, I removed \"starting and ending with a node\" from the subpath definition to make it more general, so we could have a subpath that includes several links, no nodes.",
              "createdAt": "2019-10-24T14:42:57Z",
              "updatedAt": "2019-10-24T15:00:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2NjM2NTYx",
          "commit": {
            "abbreviatedOid": "154e3e0"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T14:49:51Z",
          "updatedAt": "2019-10-24T14:49:52Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Right, I see. You're right, having multiple subpaths in there might get too confusing, so I'll change it back. A property should apply to one or a sequence of path elements (and maybe a flow), so only one subpath.\r\nI like your idea of an abstract link: For cases in which this subpath changes frequently, either we care and have insight into these path elements, or we do not care and just use an abstract link.",
              "createdAt": "2019-10-24T14:49:52Z",
              "updatedAt": "2019-10-24T15:00:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2NjQxNzE0",
          "commit": {
            "abbreviatedOid": "154e3e0"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks for the review and for the text change, I think your wording sounds much better :)\r\nI addressed your comments by adding the multicast/broadcast statement again, by mentioning the abstraction level, and by having a property apply to only one subpath, not multiple.\r\n\r\nAbout viewing a link as just another node that forwards packets, this sounds kind of confusing to me and I don't think I agree:\r\nI think \"forward packets\" means different things for nodes and for links - nodes perform routing and switching, links connect one node to another. That's not the same thing, but we don't use \"forward\" for links in our definition, so we should be fine.",
          "createdAt": "2019-10-24T14:56:10Z",
          "updatedAt": "2019-10-24T14:56:10Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5MzQ3NDYy",
          "commit": {
            "abbreviatedOid": "15964a3"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-30T16:30:41Z",
          "updatedAt": "2019-10-30T16:30:41Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Ok, that works for me",
              "createdAt": "2019-10-30T16:30:41Z",
              "updatedAt": "2019-10-30T16:30:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5MzU0Mjkz",
          "commit": {
            "abbreviatedOid": "15964a3"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-30T16:40:09Z",
          "updatedAt": "2019-10-30T16:40:10Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "I think the updated path definition in 15964a38fd16cadc06a88f04add65487e0499420 looks good now. I'm a bit worried that the abstraction levels are not clearly defined but I also couldn't come up with a better way to describe what we mean...",
              "createdAt": "2019-10-30T16:40:09Z",
              "updatedAt": "2019-10-30T16:40:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5MzYwMDcw",
          "commit": {
            "abbreviatedOid": "15964a3"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-30T16:48:02Z",
          "updatedAt": "2019-10-30T16:48:02Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "If we go with an abstract link, do we need to explicitly state that links can be abstract or is the implicit statement you added (_, and entities may treat path elements at different levels of abstraction_) enough?\r\nI think we should keep it as it is in 15964a38fd16cadc06a88f04add65487e0499420 and not make the terminology more complex.",
              "createdAt": "2019-10-30T16:48:02Z",
              "updatedAt": "2019-10-30T16:48:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzczNzQ4",
          "commit": {
            "abbreviatedOid": "15964a3"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T10:05:44Z",
          "updatedAt": "2019-11-01T10:05:44Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Agree, let's keep it like this for now and see what the Research Group thinks.",
              "createdAt": "2019-11-01T10:05:44Z",
              "updatedAt": "2019-11-01T10:05:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 22,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM0MzY0Nzc1",
      "title": "Remove domain/backbone classification, address #15 and #16",
      "url": "https://github.com/panrg/path-properties/pull/22",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This removes the domain/backbone classification, leaving only dynamic and non-dynamic properties.\r\n\r\nRight now, dynamic properties relate to the transmission of a specific flow and non-dynamic are everything else - not sure yet if the naming still makes sense this way.\r\nOther ideas for definitions or names?\r\n\r\nAnyway, I think that this addresses the remaining comments in #15 and #16.",
      "createdAt": "2019-10-30T16:15:44Z",
      "updatedAt": "2019-11-04T10:49:33Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "50c57596fc586b1e904d8f30560ff6d3b8ae2a02",
      "headRepository": "panrg/path-properties",
      "headRefName": "domain-properties",
      "headRefOid": "4fb6e26aafcad9b4a5793df9c312c12c2ea132c5",
      "closedAt": "2019-11-04T10:49:33Z",
      "mergedAt": "2019-11-04T10:49:32Z",
      "mergedBy": "theri",
      "mergeCommit": {
        "oid": "44eaca5260c6fbbbf1089bb33ad172b3ac8ae7cb"
      },
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "Maybe getting rid of all the classifications is the easiest thing to do, because every time I try to come up with another classification, there is at least one property that applies to both classifications...\r\nFor example if we simply say relevant for performance vs not relevant for performance, then we have the issue that (almost) all properties are potentially relevant for the performance.\r\n\r\nBut I think classifying based on how a property **expresses** the transmission performance might be a good idea. Since for a transmission, the properties (loss, delay, link usage) are what's mostly important and not the underlying properties such as link capacity, disjointness, or access technology that lead to the experienced performance. So we could maybe have _transmission performance properties_ (loss, delay, link usage) vs _other properties_. Then we could put the _other properties_ first and after that add a subsection for the _transmission performance properties_.\r\nWhat do you think about this?",
          "createdAt": "2019-11-01T15:09:09Z",
          "updatedAt": "2019-11-01T15:09:09Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, I think saying that the property expresses transmission performance, so it's a transmission performance property, sounds like a possible classification.\r\nHaving the other category be \"other\" properties sounds kind of awkward though, especially having an \"other\" category that comes first. Or do you mean we don't make the \"other\" category explicit and simply say that these are examples of path properties, and then there's path properties that specifically express transmission performance? That could work, but then I wouldn't put them in a subsection, because having only a single subsection doesn't really make sense.\r\nSo, should we get rid of the subsections, have text about the \"other\" properties first, then list them, then have some text about the transmission performance properties, and list them?",
          "createdAt": "2019-11-01T15:51:10Z",
          "updatedAt": "2019-11-01T15:51:10Z"
        },
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes that is what I had in mind to at least provide some structure in this section instead of simply dumping a list of properties ;)\r\nI agree that a single subsection looks wierd so separating the performance properties by some text is a good idea.",
          "createdAt": "2019-11-01T16:38:22Z",
          "updatedAt": "2019-11-01T16:38:22Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Okay, all properties are now in the same section, without any subsections, but separated by text.\r\nI chose to keep some text on how properties may be more or less dynamic, with the idea that it's not necessary to have a clear distinction, in the same way properties may apply to path elements close or less close to a host, but we don't have to define \"close\".\r\nDo you think this works?\r\n\r\nAlso, I removed one sentence from the Introduction because we don't actually have a separate section talking about path property classification anymore.",
          "createdAt": "2019-11-01T17:05:38Z",
          "updatedAt": "2019-11-01T17:05:38Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh, by the way, I got rid of the sentence \"Some dynamic properties are defined in different directions for the same path element, e.g., for transmitting and receiving packets.\" because links are unidirectional now and a single packet is only sent in one direction. Do you agree?\r\n\r\nAlso, I'm wondering if we want to get rid of the very last property, \"Congestion\" - I'm not sure if we really need this in our list and I'm not sure it belongs with the transmission performance properties.",
          "createdAt": "2019-11-01T17:18:23Z",
          "updatedAt": "2019-11-01T17:18:23Z"
        },
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "The document looks good now. I removed the congestion path property since ECN is already mentioned before and added ethernet MTU as a non-dynamic property.\r\n\r\nI agree that it is unnecessary to explicitly mention the direction of a property.\r\n\r\nI was thinking whether we want to move \"Link Capacity\" away from the transmission performance path properties since we are usually interested in the \"Link Usage\" for the performance.\r\nBut since these two properties fit together nicely, I would leave it as it is now.",
          "createdAt": "2019-11-04T10:23:39Z",
          "updatedAt": "2019-11-04T10:23:39Z"
        },
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "Btw., did the PANRG chairs reply whether we should upload the draft as draft-irtf... or draft-enghardt...?",
          "createdAt": "2019-11-04T10:28:12Z",
          "updatedAt": "2019-11-04T10:28:12Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the further changes, I agree this is ready to go now.\r\nI talked to the chairs and we'll submit it as draft-enghardt again this time, then confirm the adoption in the PANRG session.\r\nI'll get the submission ready this afternoon. ",
          "createdAt": "2019-11-04T10:48:25Z",
          "updatedAt": "2019-11-04T10:48:25Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5NDEyMDc4",
          "commit": {
            "abbreviatedOid": "37ede29"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I'll try to think more about the classification tomorrow.\r\n\r\n> I'll ask PANRG about the use case section at IETF 106 if we can get beyond the Terminology section. ;)\r\n\r\nLet's hope for the best :D",
          "createdAt": "2019-10-30T18:01:57Z",
          "updatedAt": "2019-10-30T18:15:07Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "I can't come up with another good naming than dynamic vs non-dynamic. I think if we use \"flow\", e.g., \"Flow Properties\", then this would indicate that other properties are not defined for a flow, which is not necessarily always the case. As an example, we defined \"Monetary cost\" and \"Service function\" as non-dynamic properties which relate to a flow.\r\n\r\nInstead of dynamic, we could maybe label them as short-term and long-term properties and refer to the expected time for which the property is useful.",
              "createdAt": "2019-10-30T18:01:57Z",
              "updatedAt": "2019-11-04T10:14:58Z"
            },
            {
              "originalPosition": 46,
              "body": "Dynamic properties relate to individual path elements/subpaths as well (see previous comment).",
              "createdAt": "2019-10-30T18:03:09Z",
              "updatedAt": "2019-11-04T10:14:58Z"
            },
            {
              "originalPosition": 48,
              "body": "I would rewrite this as: \"The visibility of path properties to a specific entity may depend on factors such as the physical or network distance or the existence of trust or contractual relationships between the entity and the path element(s).\"",
              "createdAt": "2019-10-30T18:05:34Z",
              "updatedAt": "2019-11-04T10:14:58Z"
            },
            {
              "originalPosition": 100,
              "body": "As said in the first comment, maybe we should change this since this also includes some non-dynamic path properties.",
              "createdAt": "2019-10-30T18:10:28Z",
              "updatedAt": "2019-11-04T10:14:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzc5NTYz",
          "commit": {
            "abbreviatedOid": "37ede29"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T10:20:34Z",
          "updatedAt": "2019-11-01T10:20:35Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Sounds much better! Changing it.",
              "createdAt": "2019-11-01T10:20:34Z",
              "updatedAt": "2019-11-04T10:14:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzgzNTY4",
          "commit": {
            "abbreviatedOid": "37ede29"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T10:31:07Z",
          "updatedAt": "2019-11-01T10:31:07Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "You're right, both dynamic and non-dynamic properties may relate to the transmission of a specific flow.\r\nWhat I meant here was: Dynamic properties express something related to the performance of transmitting this flow over these path elements. Right? All of the current dynamic properties directly express some kind of performance measurement, like how long the transmission took or how much data can be transmitted over time. And none of the non-dynamic properties directly expresses some performance measurement.\r\nSo maybe something like \"performance properties\" or \"transmission performance properties\"?\r\n\r\nI think we used \"dynamic\" or \"short-term\" for these properties but actually meant that a specific measurement of these properties is a momentary thing, and performance changes over time, so the next measurement might be different.\r\nHowever, I'm rethinking \"dynamic\" or \"short-term\" because the Link Capacity is actually not something I'd expect to change all the time. For a single link, it might not actually change that much (like for an Ethernet cable), and for a path, it might only change when the path changes, similar to what we have for \"non-dynamic\" properties right now.\r\n\r\nOf course, our last resort could be to just get rid of all the classifications for now, if we can't decide ;)",
              "createdAt": "2019-11-01T10:31:07Z",
              "updatedAt": "2019-11-04T10:14:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzg0MzMx",
          "commit": {
            "abbreviatedOid": "37ede29"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T10:33:13Z",
          "updatedAt": "2019-11-01T10:33:13Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "True... but how to phrase this then?",
              "createdAt": "2019-11-01T10:33:13Z",
              "updatedAt": "2019-11-04T10:14:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMzg2MDI4",
          "commit": {
            "abbreviatedOid": "37ede29"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "You're right, the current classification doesn't really work. Maybe it's just a matter of renaming it, but then I wonder how we'd define \"short term\" and \"long term\".\r\nSo I'm actually thinking in another direction: Does the property express the performance of a transmission or not.\r\nThen again, I'm not sure if we really need this distinction after all, or if we can maybe get away with just saying \"usefulness changes over time, here's a list of different properties, use your brain\" ;)",
          "createdAt": "2019-11-01T10:37:30Z",
          "updatedAt": "2019-11-01T10:37:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 30,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY4NjE0NTM0",
      "title": "Editorial and definition changes based on Med's review of -03",
      "url": "https://github.com/panrg/path-properties/pull/30",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This should cover everything discussed in #23 except the use cases section, which we tackle in another issue.\r\nI added the definitions we promised to add while limiting our scope to definitions, i.e., not trying to go into how paths and path properties can be discovered. That's also why I cut some details for the \"Transport Protocols available\" property: Sure, a host can cache this because it's visible locally, but also based on probing as Med correctly pointed out, but let's try to avoid going into these different possibilities here.",
      "createdAt": "2020-01-29T15:20:10Z",
      "updatedAt": "2020-03-07T08:37:41Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "956ad2378a16e610d2b790bf36a6359fa34b3010",
      "headRepository": "panrg/path-properties",
      "headRefName": "address-med-review-03",
      "headRefOid": "dabfa7d327a00cedb813484e4963b036ff75bd17",
      "closedAt": "2020-03-07T08:37:41Z",
      "mergedAt": "2020-03-07T08:37:41Z",
      "mergedBy": "theri",
      "mergeCommit": {
        "oid": "b5886188da5bb786ee25dc8575be79b79a9b9877"
      },
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this looks fine now, so from my side, we can merge it",
          "createdAt": "2020-03-06T14:49:49Z",
          "updatedAt": "2020-03-06T14:49:49Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5MDk2ODIx",
          "commit": {
            "abbreviatedOid": "169ecb5"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I like most of the changes but I'm not yet sure about the definition of the symmetric path.\r\nI will try to come up with a better way of defining it.",
          "createdAt": "2020-02-14T17:18:55Z",
          "updatedAt": "2020-02-14T17:25:30Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "I like the first sentence but I'm not sure if reverse([PE1,PE2,PE3]) = [PE3,PE2,PE1] is always true since a path element might not have a reverse path element, especially for virtual nodes (e.g., node that drops packets in one direction => no corresponding reverse node).\r\n\r\nMaybe we could say that there are different degrees of symmetry, e.g., only a subset of nodes is symmetric (I could imagine an IP symmetric path where nodes describing IP routers that decrease the TTL are symmetric).",
              "createdAt": "2020-02-14T17:18:56Z",
              "updatedAt": "2020-02-21T15:02:36Z"
            },
            {
              "originalPosition": 33,
              "body": "I like this definition as it is generally applicable.",
              "createdAt": "2020-02-14T17:20:16Z",
              "updatedAt": "2020-02-21T15:02:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5MzQzNjI4",
          "commit": {
            "abbreviatedOid": "169ecb5"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-15T12:40:58Z",
          "updatedAt": "2020-02-15T12:40:59Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "I would have thought that a path is symmetric if the return path consists of the same path elements, but just in the reverse order/direction, but yes, there might be cases where this is not entirely true. Also, the \"same link in the reverse direction\" might be a problem sometimes.\r\n\r\nMaybe here we could use disjointness, which we define later. So maybe we could move \"Symmetric path\" to the examples section because it's essentially a special case of disjointness, right?",
              "createdAt": "2020-02-15T12:40:58Z",
              "updatedAt": "2020-02-21T15:02:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwODk4MDMy",
          "commit": {
            "abbreviatedOid": "23dd972"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-19T07:49:53Z",
          "updatedAt": "2020-02-19T07:49:54Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "I like this suggestion and added it in 23dd972.\r\nWhat do you think about the changes?",
              "createdAt": "2020-02-19T07:49:53Z",
              "updatedAt": "2020-02-21T15:02:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyNjkyMzU4",
          "commit": {
            "abbreviatedOid": "dabfa7d"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-21T15:04:10Z",
          "updatedAt": "2020-02-21T15:04:11Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Thanks for moving the definition! I think it makes more sense as a separate item, so I separated it out from the Disjointness definition.\r\nAlso, I merged the 'master' branch into this one to resolve the merge conflicts in our Path definition and Access Technology definition.",
              "createdAt": "2020-02-21T15:04:11Z",
              "updatedAt": "2020-02-21T15:04:11Z"
            }
          ]
        }
      ]
    },
    {
      "number": 31,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY4NjQzMzg3",
      "title": "Refactor use cases, fix #29",
      "url": "https://github.com/panrg/path-properties/pull/31",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on the comments we got at IETF 106 and on Med's review, I refactored the use cases.\r\nI removed Performance Monitoring and Enhancement because monitoring was mostly talking about how to get path properties (which is out of scope for our draft) and then enhancement can take different forms: Path selection, protocol selection/configuration, service invocation, or perhaps others.\r\nHere I'm just wondering whether to include a reference to LOOPS somewhere, e.g., a path element adding some FEC on some encapsulated traffic based on path properties. But we don't really have an adopted draft for that yet, while other examples such as TCP converters and performance routing are already adopted IETF documents.\r\n\r\nI reshuffled the Path Selection section a bit because I think the part of when you can do path selection  should come earlier, and also the warning to be aware of their limitations, before going into examples.\r\n\r\nFinally I split Protocol Selection and Service Invocation (named based on a suggestion by Med), because I think these are really separate things to do to your traffic and/or path.\r\n\r\nPlease let me know what you think. :)\r\n\r\nBTW, I'd like to get a new revision out soon-ish (within the next few weeks), i.e., before my planned relocation.\r\nIf you want to do a PR for any of the remaining issues yourself before then, feel free to self-assign an issue.",
      "createdAt": "2020-01-29T16:14:08Z",
      "updatedAt": "2020-02-19T07:52:21Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "c4a1a710f6b35cfe3b20ac4c9b091b5bf019d36d",
      "headRepository": "panrg/path-properties",
      "headRefName": "refactor-use-cases",
      "headRefOid": "a6d104d1230943d5523e897717c3fe17eda8eb9f",
      "closedAt": "2020-02-19T07:52:21Z",
      "mergedAt": "2020-02-19T07:52:21Z",
      "mergedBy": "cyrill-k",
      "mergeCommit": {
        "oid": "2e0ac8bb1eb0d45e607a5164f82da2349402ddd9"
      },
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "I made a commit a6d104d with some small textual changes and I added the following to the path selection use case:\r\n\r\nPath selection based on measurements might not just be useless but could also be harmful for the stability.\r\n",
          "createdAt": "2020-02-14T15:36:19Z",
          "updatedAt": "2020-02-14T15:36:19Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the commit, I like your changes!\r\nSo, can we merge this already?",
          "createdAt": "2020-02-15T12:28:13Z",
          "updatedAt": "2020-02-15T12:28:13Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 32,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc0MzQzOTg2",
      "title": "Clarifications, fix #24",
      "url": "https://github.com/panrg/path-properties/pull/32",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Explicitly stated some points that people keep misunderstanding in response to #24:\r\n\r\n- Make scope of the document explicit\r\n- Add examples to our path definition to make the concept of \"different levels of abstractions\" clearer\r\n- Refactored Access Technology to make it clearer how this relates to either links or nodes",
      "createdAt": "2020-02-12T14:38:12Z",
      "updatedAt": "2020-02-19T08:05:17Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "c4a1a710f6b35cfe3b20ac4c9b091b5bf019d36d",
      "headRepository": "panrg/path-properties",
      "headRefName": "clarifications-luis-contreras",
      "headRefOid": "4e25d036e99caad2e09ce3bfd77c9e51c3d1dd89",
      "closedAt": "2020-02-19T08:05:16Z",
      "mergedAt": "2020-02-19T08:05:16Z",
      "mergedBy": "cyrill-k",
      "mergeCommit": {
        "oid": "956ad2378a16e610d2b790bf36a6359fa34b3010"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4OTg3NDgw",
          "commit": {
            "abbreviatedOid": "e0426ec"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-02-14T14:42:43Z",
          "updatedAt": "2020-02-14T14:49:36Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I would change the last sentence to \"Similarly, the representation of a path and its properties, as it is known to a specific entity, may be more complex and include details about the physical layer technology, or it may be more abstract and only consist of a specific source and destination.\"\r\n\r\nSince saying \"only include a route\" does not necessarily mean that the route is abstract and also we didn't define what a route is.",
              "createdAt": "2020-02-14T14:42:43Z",
              "updatedAt": "2020-02-19T08:03:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5MzQxNTIx",
          "commit": {
            "abbreviatedOid": "e0426ec"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-15T11:45:07Z",
          "updatedAt": "2020-02-15T11:45:08Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Agree, \"only include a route\" is not specific enough here.\r\nWhat I meant here is the information that a specific destination is reachable. I think your proposed sentence works, because if a path consists of a specific source and destination, this implies that it is reachable, otherwise it wouldn't be a path according to our definition.\r\nHowever, if we want to be really really clear, how about \"only consist of a specific source and a destination which is known to be reachable from that source\"?",
              "createdAt": "2020-02-15T11:45:07Z",
              "updatedAt": "2020-02-19T08:03:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwOTA0ODky",
          "commit": {
            "abbreviatedOid": "4e25d03"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-19T08:04:27Z",
          "updatedAt": "2020-02-19T08:04:27Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Ok, I changed the sentence",
              "createdAt": "2020-02-19T08:04:27Z",
              "updatedAt": "2020-02-19T08:04:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 33,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc3MDczNTU0",
      "title": "Add transparency property",
      "url": "https://github.com/panrg/path-properties/pull/33",
      "state": "MERGED",
      "author": "cyrill-k",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I defined transparency as a property of a service function.\r\n\r\nI'm not sure if this restricts the usefulness of the transparency property.\r\nAre there cases where transparency is relevant for nodes/links that are not service functions?\r\n\r\nDo you have other suggestions how to define it?",
      "createdAt": "2020-02-19T10:04:34Z",
      "updatedAt": "2020-03-07T08:37:16Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "956ad2378a16e610d2b790bf36a6359fa34b3010",
      "headRepository": "panrg/path-properties",
      "headRefName": "transparency",
      "headRefOid": "68c55a0c6a4105d40b1c2f2a48fd95fddbd986bb",
      "closedAt": "2020-03-07T08:37:16Z",
      "mergedAt": "2020-03-07T08:37:16Z",
      "mergedBy": "theri",
      "mergeCommit": {
        "oid": "7735f7e9d767ba9238fb841eff5aa0010212b03c"
      },
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "I like the change from service function to node since it is more applicable.\r\nBut I think saying if a node records meta-info about a protocol it cannot be transparent to that protocol is perfect since the node might simply parse the complete packet but not act on the meta-info. Maybe we can say if the node doesn't act based on the meta-info recorded for a protocol, the node is transparent to this protocol.\r\n\r\nI revised the text but I'm not too happy with the sentence yet. If you see a way to describe it more nicely, feel free to change it.",
          "createdAt": "2020-03-06T15:13:50Z",
          "updatedAt": "2020-03-06T15:13:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyNzIxMTgy",
          "commit": {
            "abbreviatedOid": "b5ec479"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for the suggestion!\r\n\r\nI like the general direction and the example. However, I'm not sure we really want to define this based on service functions. I looked at RFC 7665 again, which defines Service Function as a \"function that is responsible for specific treatment of received packets\", and I find that rather vague and open-ended. I'm not even sure everyone would agree that forwarding a packet is a service function.\r\n\r\nHow about simply saying \"A node is transparent with respect to a protocol if it does not read and/or modify headers of this protocol and does not record meta-information related to this protocol when processing packets\"?\r\nAs we define a node as an \"entity which processes packets\", this is basically a more specific way of talking about how a particular node processes, or does not process, particular parts of packets.",
          "createdAt": "2020-02-21T15:43:18Z",
          "updatedAt": "2020-02-21T15:43:18Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNzMxOTY1",
          "commit": {
            "abbreviatedOid": "68c55a0"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for the changes!\r\nI agree that we can define just reading but not modifying headers as transparent.\r\nI'm okay with the wording as it is. This is a first proposal and we'll iterate on it anyway.",
          "createdAt": "2020-03-07T08:36:54Z",
          "updatedAt": "2020-03-07T08:36:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 34,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc3MTAyNzM2",
      "title": "Discuss secrecy/integrity protection in the Security Considerations",
      "url": "https://github.com/panrg/path-properties/pull/34",
      "state": "MERGED",
      "author": "cyrill-k",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Adds a paragraph to Security Considerations to discuss encryption and integrity protection and why we don't need explicit path properties for this.",
      "createdAt": "2020-02-19T11:02:03Z",
      "updatedAt": "2020-03-07T08:44:14Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "956ad2378a16e610d2b790bf36a6359fa34b3010",
      "headRepository": "panrg/path-properties",
      "headRefName": "secrecy-integrity-protection",
      "headRefOid": "4a6efbe9f9d0da8602ff110fd51c0cd581bc9856",
      "closedAt": "2020-03-07T08:44:14Z",
      "mergedAt": "2020-03-07T08:44:14Z",
      "mergedBy": "theri",
      "mergeCommit": {
        "oid": "cbaa1502d2409937559e567962fd193bacf8ac19"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyODM4ODcz",
          "commit": {
            "abbreviatedOid": "8a8a0ce"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thank you for the PR!\r\n\r\nI really like the idea to not define any such property and to explain why in the Security Considerations.\r\n\r\nAbout this text, I agree it's good to start out saying this is only useful with regards to a threat model, but I have some suggestions to reword the first sentence.\r\nThen, I'd like to put in your point from #27: \"we would also have to specify which entities hold en-/decryption keys\".\r\nFinally, so far the explanation why security properties are orthogonal does not work for me, although intuitively I agree that this is true.\r\n\r\nSo, let's iterate on this part to have a starting point for the Research Group to discuss this further.",
          "createdAt": "2020-02-21T18:46:10Z",
          "updatedAt": "2020-02-21T19:14:07Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I think by itself, the part after the \"e.g.\" does not illustrate why secrecy (confidentiality?) and integrity protection are orthogonal. I'm missing a verb there and it's not clear to me what the VPN has to do with the properties.\r\nHowever, I agree they might indeed be orthogonal, I'm just wondering we'd explain this here.\r\n\r\nMaybe the explanation has to do with what you write in #27, that encryption/integrity protection depends on the protocol used. I guess whether specific parts of a packet are encrypted is a property of the packet and not a property related to a specific path. You can say \"this packet has encrypted headers XYZ and only path elements A and B have the key\", but you can't really say \"path elements A and B are exchanging encrypted traffic\" because it wouldn't apply to all parts of the packet or to all packets - unless there's a tunnel. But this sentence should first make a general point, right? And then we could dive into the special case of tunnels, or we could not. I'm not convinced we need a tunnel property either.\r\n\r\nSo, I'm still wondering how to untangle this, but maybe as a first suggestion:\r\n\"Such properties are orthogonal to the path terminology and path properties defined in this document, as they relate to specific parts of specific packets in case a specific protocol is used.\"\r\nBut we might want to write more here.",
              "createdAt": "2020-02-21T18:46:10Z",
              "updatedAt": "2020-03-06T14:42:23Z"
            },
            {
              "originalPosition": 4,
              "body": "Some suggestions to reword this sentence:\r\n- Consider substituting \"secrecy\" with \"confidentiality\", as I think that term is more common.\r\n- Consider switching out \"they are defined\" with \"they are only meaningful\" or similar - I think you can define them without a threat model, but it doesn't really make sense as in that case you can't really reason about these properties or draw any conclusions from them.\r\n- Consider switching out \"depending on the protocol and application\" with something broader, like \"depending on the use case, application, environment, and other factors\". Otherwise I'd say it's too narrow.",
              "createdAt": "2020-02-21T18:53:16Z",
              "updatedAt": "2020-03-06T14:42:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMzY5MDgy",
          "commit": {
            "abbreviatedOid": "8a8a0ce"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-06T14:39:55Z",
          "updatedAt": "2020-03-06T14:39:55Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I will try to expand a bit on the point that confidentiality and integrity are defined by the communicating parties (entities holding en-/decryption keys) and do (typically) not depend on the underlying path.\r\n\r\nI also think we do not need to define a tunnel, but if I would have to add these confidentiality and integrity as a property, I would probably define them in some kind of \"tunnel\" property.",
              "createdAt": "2020-03-06T14:39:55Z",
              "updatedAt": "2020-03-06T14:42:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMzY5NjE5",
          "commit": {
            "abbreviatedOid": "8a8a0ce"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-06T14:40:39Z",
          "updatedAt": "2020-03-06T14:40:39Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I like these suggestions and I'll add them the next commit.",
              "createdAt": "2020-03-06T14:40:39Z",
              "updatedAt": "2020-03-06T14:42:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNzMyMjQx",
          "commit": {
            "abbreviatedOid": "4a6efbe"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for the changes!\r\nLooks good to me now. Looking forward to seeing what the Research Group thinks.",
          "createdAt": "2020-03-07T08:44:04Z",
          "updatedAt": "2020-03-07T08:44:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 38,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc1OTA3ODIz",
      "title": "Add examples to host definition",
      "url": "https://github.com/panrg/path-properties/pull/38",
      "state": "MERGED",
      "author": "cyrill-k",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Add examples (web browser for client node and web server for server node) to host definition",
      "createdAt": "2020-08-30T12:54:30Z",
      "updatedAt": "2020-09-02T15:16:09Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "944007249fc2ee7fee5564e21e26fad44f1df370",
      "headRepository": "panrg/path-properties",
      "headRefName": "clarify-host-definition",
      "headRefOid": "0910c8b4ce741e04783d3f74113f44cf6a5d6eae",
      "closedAt": "2020-09-02T15:16:09Z",
      "mergedAt": "2020-09-02T15:16:09Z",
      "mergedBy": "cyrill-k",
      "mergeCommit": {
        "oid": "a7554a5a264c7fb846c41ae6ff37fd7f7ed9dc1c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc5MzYxMDg2",
          "commit": {
            "abbreviatedOid": "78a16b2"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for this PR! Just a wording suggestion. ",
          "createdAt": "2020-09-01T02:36:39Z",
          "updatedAt": "2020-09-01T02:37:59Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\nNote that hosts include both client nodes (e.g., running a web browser) and server nodes (e.g., running a web server).\r\n```\r\n\"deploying\" sounds confusing to me, as if the server was installing the software to another machine. For me, \"deploying\" is definitely not a synonym of running.",
              "createdAt": "2020-09-01T02:36:39Z",
              "updatedAt": "2020-09-02T15:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc5MzYxNzAw",
          "commit": {
            "abbreviatedOid": "78a16b2"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-01T02:38:51Z",
          "updatedAt": "2020-09-01T02:38:52Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "If you really want \"deploy\", how about \"[\u2026] and server nodes (e.g., on which a web server is deployed)\"?",
              "createdAt": "2020-09-01T02:38:51Z",
              "updatedAt": "2020-09-02T15:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwOTI4ODAy",
          "commit": {
            "abbreviatedOid": "78a16b2"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T15:14:53Z",
          "updatedAt": "2020-09-02T15:14:53Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I agree that it is more clear to use running consistently",
              "createdAt": "2020-09-02T15:14:53Z",
              "updatedAt": "2020-09-02T15:15:08Z"
            }
          ]
        }
      ]
    },
    {
      "number": 39,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc1OTA4Nzg0",
      "title": "Note that we do not define trust properties because we do not define \u2026",
      "url": "https://github.com/panrg/path-properties/pull/39",
      "state": "MERGED",
      "author": "cyrill-k",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Note that we do not define trust properties because we do not define a threat model",
      "createdAt": "2020-08-30T13:03:34Z",
      "updatedAt": "2020-09-04T21:56:44Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "944007249fc2ee7fee5564e21e26fad44f1df370",
      "headRepository": "panrg/path-properties",
      "headRefName": "trust-property",
      "headRefOid": "86cb13e61977bd8cf58014a10994976b71d07068",
      "closedAt": "2020-09-04T21:56:44Z",
      "mergedAt": "2020-09-04T21:56:44Z",
      "mergedBy": "theri",
      "mergeCommit": {
        "oid": "be1387305d3715267f7a5d019afc445738edf6b8"
      },
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "I rephrased the long sentence.\r\nWhat do you think?",
          "createdAt": "2020-09-02T15:12:38Z",
          "updatedAt": "2020-09-02T15:12:38Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc5MzYyMDgx",
          "commit": {
            "abbreviatedOid": "921ded4"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Looks good! Just added two suggestions to consider.",
          "createdAt": "2020-09-01T02:40:19Z",
          "updatedAt": "2020-09-01T02:42:37Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\nLikewise, properties for trust relations between nodes cannot be meaningfully defined without a concrete threat model, and defining a threat model is out of scope for this draft.\r\n```",
              "createdAt": "2020-09-01T02:40:19Z",
              "updatedAt": "2020-09-02T15:10:35Z"
            },
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nProperties related to confidentiality, integrity, and trust are orthogonal to the path terminology and path properties defined in this document, as they are tied to the communicating entities and protocols used (e.g., client and server using HTTPS, or client and remote network node using VPN) and the path is typically oblivious to these properties.\r\n```\r\nTrying to make it go well with the sentence before.\r\nAlso, this sentence is rather long, maybe we should split it? But I can't immediately see a good way to do so. Doesn't have to be in this PR.",
              "createdAt": "2020-09-01T02:41:21Z",
              "updatedAt": "2020-09-02T15:10:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwOTEwODc5",
          "commit": {
            "abbreviatedOid": "921ded4"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Security Considerations Textual changes",
          "createdAt": "2020-09-02T14:59:47Z",
          "updatedAt": "2020-09-02T15:01:50Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Good idea.",
              "createdAt": "2020-09-02T14:59:48Z",
              "updatedAt": "2020-09-02T15:10:35Z"
            },
            {
              "originalPosition": 5,
              "body": "I like the changes.\r\ni will split the long sentence in another commit",
              "createdAt": "2020-09-02T15:01:22Z",
              "updatedAt": "2020-09-02T15:10:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyOTg1Nzgw",
          "commit": {
            "abbreviatedOid": "86cb13e"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good to me! Thank you.",
          "createdAt": "2020-09-04T21:56:37Z",
          "updatedAt": "2020-09-04T21:56:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 40,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc1OTExNjEx",
      "title": "Consider path as symmetric on a given level of abstraction",
      "url": "https://github.com/panrg/path-properties/pull/40",
      "state": "MERGED",
      "author": "cyrill-k",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I defined a path as symmetric only for a given level of abstraction and added IP routing symmetric paths as an example.\r\n\r\nBut I'm not convinced that covers all cases, as the order might not be relevant for certain service functions as Gorry pointed out.\r\nWhat we could do is phrase the definition more generally:\r\n\"Two paths are symmetric if the path and its reverse path consist of the same path elements on the same level of abstraction, ~~but~~ **typically** in reverse order\"",
      "createdAt": "2020-08-30T13:29:20Z",
      "updatedAt": "2020-09-04T21:52:27Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "944007249fc2ee7fee5564e21e26fad44f1df370",
      "headRepository": "panrg/path-properties",
      "headRefName": "symmetric-path",
      "headRefOid": "73fe8de62df02dac8c2d208d53090838e0824377",
      "closedAt": "2020-09-04T21:52:27Z",
      "mergedAt": "2020-09-04T21:52:27Z",
      "mergedBy": "theri",
      "mergeCommit": {
        "oid": "c941859d62946878c157c4dcded79ff1de915dcd"
      },
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "I rephrased the service function example and added the textual fixes",
          "createdAt": "2020-09-02T14:51:34Z",
          "updatedAt": "2020-09-02T14:51:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc5MzYzODA5",
          "commit": {
            "abbreviatedOid": "bcb7ea3"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for this first stab!\r\nI think that, as our definition relates to path elements that comprise the path, it's necessarily routing/forwarding-specific, so it doesn't apply to service functions.\r\n\r\nI'd be in favor of keeping the definition as it is (in this PR), but address Gorry's comment elsewhere in the draft.\r\nMaybe we should change the last sentence of our definition of Service function:\r\n\"Some stateful service functions, such as NAT, need to observe the same flow in both directions, e.g., by being an element of both the path and the reverse path.\" \r\n\r\nI think the \"e.g.\" makes it sufficiently clear that the paths do not have to be symmetric and the NAT being a path element in both directions is just one example of how to achieve the requirement.",
          "createdAt": "2020-09-01T02:46:34Z",
          "updatedAt": "2020-09-01T02:56:47Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nFor example, a path which consists of layer 3 switches and links between them and a reverse path with the same path elements but in reverse order are considered \"routing\" symmetric, as the same path elements on the same level of abstraction (IP forwarding) are traversed in the opposite direction.\r\n```\r\nThis is an example of the previous definition, right? I think it's worth making this explicit.\r\nAlso, we already use \"layer 2 domain\" and \"IP-layer\" elsewhere in the draft, and I think it's good to try to be consistent. \"IP-layer switch\" sounds weird, therefore I'd go with \"layer 3\" (no hyphen) here.",
              "createdAt": "2020-09-01T02:46:34Z",
              "updatedAt": "2020-09-02T14:50:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyOTg0NDI1",
          "commit": {
            "abbreviatedOid": "73fe8de"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks, looks good to me!",
          "createdAt": "2020-09-04T21:52:06Z",
          "updatedAt": "2020-09-04T21:52:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 41,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc1OTE3NDU1",
      "title": "Add table for different degrees of transparency",
      "url": "https://github.com/panrg/path-properties/pull/41",
      "state": "MERGED",
      "author": "cyrill-k",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I added a table for different node behaviors (block, modify, ...) based on different inputs.\r\nI'm not sure if this table is useful/consistent since different actions might have different inputs which cannot be represented in a reasonably small table.\r\n\r\nAn alternative approach instead of the table would be to add some text which describes the main takeaways from the table, i.e., node might block but not modify, node might modify headers but be transparent to payloads, ...",
      "createdAt": "2020-08-30T14:19:58Z",
      "updatedAt": "2020-09-04T21:51:15Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "944007249fc2ee7fee5564e21e26fad44f1df370",
      "headRepository": "panrg/path-properties",
      "headRefName": "extended-transparency",
      "headRefOid": "ce1b97ae1b8e55ea58266626b383848ae61a45fd",
      "closedAt": "2020-09-04T21:51:15Z",
      "mergedAt": "2020-09-04T21:51:14Z",
      "mergedBy": "theri",
      "mergeCommit": {
        "oid": "f5b908bcc99324dc775d57045bec9930c940637b"
      },
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "I changed it to a textual description.\r\nWhat do you think?",
          "createdAt": "2020-09-02T14:20:29Z",
          "updatedAt": "2020-09-02T14:20:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc5MzY5OTU5",
          "commit": {
            "abbreviatedOid": "d64978e"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for giving this a try!\r\n\r\nThe table is probably a good exercise, but it suggests that it captures all cases, and I'm not sure either if it indeed does. For example, is it still \"transparent\" if the node reads the header, but does not modify it?\r\nFor now I suggest to remove that table, but add some text that describes the takeaways, as you suggest.\r\n\r\nPerhaps we could talk about a node being \"transparent\" with respect to a \"header\" and \"payload\" of certain protocol, or if it is not transparent, it may \"read\" or \"modify\" the header/payload, or it may \"block\" the entire packet. But I can imagine a node doing other things, e.g., inserting a header somewhere in the packet? So let's not try to come up with a classification of all things that a node might do to a packet.",
          "createdAt": "2020-09-01T03:08:12Z",
          "updatedAt": "2020-09-01T03:08:12Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyOTgzNTc3",
          "commit": {
            "abbreviatedOid": "33d0d90"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good to me, modulo a stylistic change to one sentence.",
          "createdAt": "2020-09-04T21:49:36Z",
          "updatedAt": "2020-09-04T21:50:43Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\n: A node is transparent with respect to a protocol header, payload, or both for a specific action if the node performs this action independently of the given (meta-)information.\r\n```",
              "createdAt": "2020-09-04T21:49:37Z",
              "updatedAt": "2020-09-04T21:51:03Z"
            }
          ]
        }
      ]
    },
    {
      "number": 42,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc2NzgxNTA0",
      "title": "Quote path awareness definition and relationship to this draft",
      "url": "https://github.com/panrg/path-properties/pull/42",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Reference the definition of path awareness in Section 1.1 of the Questions draft.\r\nAlso, make the initial statement less general - The current Internet does not support explicit discovery of path properties, but endpoints already do measure some properties of their paths (e.g., RTT measurements in a TCP stack).",
      "createdAt": "2020-09-01T03:23:41Z",
      "updatedAt": "2020-09-04T21:47:52Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "944007249fc2ee7fee5564e21e26fad44f1df370",
      "headRepository": "panrg/path-properties",
      "headRefName": "reference-definition-of-path-awareness",
      "headRefOid": "20244e8cde86f5a7214c92bebd7072970c1e90a1",
      "closedAt": "2020-09-04T21:47:52Z",
      "mergedAt": "2020-09-04T21:47:52Z",
      "mergedBy": "theri",
      "mergeCommit": {
        "oid": "061eddc7ea0fd7de3433d0d69d579fe545726a04"
      },
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "This change looks good to me.",
          "createdAt": "2020-09-02T14:40:32Z",
          "updatedAt": "2020-09-02T14:40:32Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 43,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc2Nzg2MTcx",
      "title": "Link to ALTO drafts",
      "url": "https://github.com/panrg/path-properties/pull/43",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Highlight that our definition is compatible with ALTO by giving it as an example.\r\nState that path properties can be made available as ALTO cost metrics.\r\nAlso, remove reference to an old paper of mine that has become irrelevant to this draft (IMO), as it is more about how to measure path properties, which is explicitly out of scope for this draft.",
      "createdAt": "2020-09-01T03:39:28Z",
      "updatedAt": "2020-09-04T21:47:34Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "944007249fc2ee7fee5564e21e26fad44f1df370",
      "headRepository": "panrg/path-properties",
      "headRefName": "link-alto-drafts",
      "headRefOid": "7f9eb883ae03d28ddfefad4e5bac41e7c2b977a9",
      "closedAt": "2020-09-04T21:47:34Z",
      "mergedAt": "2020-09-04T21:47:34Z",
      "mergedBy": "theri",
      "mergeCommit": {
        "oid": "90a09d58698fdfea4a0785d884aa0348289ef9dd"
      },
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "I added a small fix but I like the changes otherwise.",
          "createdAt": "2020-09-02T14:31:12Z",
          "updatedAt": "2020-09-02T14:31:12Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 44,
      "id": "MDExOlB1bGxSZXF1ZXN0NTcyNjc0NDEw",
      "title": "Adjust definition to questions draft, rephrase different levels of abstraction",
      "url": "https://github.com/panrg/path-properties/pull/44",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR does the following:\r\n\r\n- Update the definition of \"path aware networking\" based on the current questions draft\r\n- In the use cases section and the examples section, clarify how different entities have visibility of and control over different path elements and path properties. (Implicit: This is why the generic definition in this document becomes a specific definition in the context of a specific technology)\r\n- In the Examples section, remove some text around examples that are not really path-aware networking\r\n- Minor editorial fixes\r\n\r\nPlease let me know what you think.",
      "createdAt": "2021-02-12T17:31:41Z",
      "updatedAt": "2021-02-18T02:16:29Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "be1387305d3715267f7a5d019afc445738edf6b8",
      "headRepository": "panrg/path-properties",
      "headRefName": "theri/definition-abstraction-pre-IETF110",
      "headRefOid": "572139d89d315e7dea1d156576a37f7aff0ad10b",
      "closedAt": "2021-02-18T02:16:29Z",
      "mergedAt": "2021-02-18T02:16:29Z",
      "mergedBy": "theri",
      "mergeCommit": {
        "oid": "613989f03b3bb06c2634df4ca252336b854fc33b"
      },
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you for the review! \r\nI updated the PR. Please let me know what you think.",
          "createdAt": "2021-02-17T03:11:42Z",
          "updatedAt": "2021-02-17T03:11:42Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Given that all previous comments are resolved, I'm merging this now.",
          "createdAt": "2021-02-18T02:16:18Z",
          "updatedAt": "2021-02-18T02:16:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkxMDc3MTg1",
          "commit": {
            "abbreviatedOid": "a85fd2f"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I like the changes as they make the concept of visibility and abstraction more clear.",
          "createdAt": "2021-02-16T10:17:09Z",
          "updatedAt": "2021-02-16T11:00:07Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "I would prefer not to say a **new** level of abstraction, since this seems to indicate that our definition does not yet cover this level of abstraction:\r\n\"Moreover, for a particular technology, entities may have visibility of and control over different path elements and path properties, and consider them on different levels of abstraction.\r\nTherefore, a new technology may implement an existing use case related to other path elements or on a different level of abstraction.\"",
              "createdAt": "2021-02-16T10:17:09Z",
              "updatedAt": "2021-02-17T03:11:17Z"
            },
            {
              "originalPosition": 35,
              "body": "Maybe we can rephrase this paragraph more concisely:\r\n\"Within the context of a particular technology, available path properties may differ as entities have insight into and are able to influence different path elements and path properties.\r\nFor example, a host may have some visibility into path elements that are close, i.e., within the first few hops, or they may include path elements that are far away and/or on a different level of abstraction, e.g., the list of ASes traversed.\r\nAdditionally, the visibility may depend on factors such as the physical or network distance or the existence of trust or contractual relationships between the entity and the path element(s).\"\r\n_should we also use **host** in the last sentence as in the sentence before?_",
              "createdAt": "2021-02-16T10:34:01Z",
              "updatedAt": "2021-02-17T03:11:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkxODAxMDQ0",
          "commit": {
            "abbreviatedOid": "a85fd2f"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-17T02:59:32Z",
          "updatedAt": "2021-02-17T02:59:32Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "Agreed! Fixed.",
              "createdAt": "2021-02-17T02:59:32Z",
              "updatedAt": "2021-02-17T03:11:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkxODAzNzE3",
          "commit": {
            "abbreviatedOid": "a85fd2f"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-17T03:08:02Z",
          "updatedAt": "2021-02-17T03:08:02Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Thanks, I used the first sentence you suggested.\r\nThen, re-reading the second sentence, I rephrased it a bit, as I think its grammar was broken and I wanted more symmetry between the two options (low VS higher abstraction level and being close VS far away). Please let me know what you think.\r\nFor the last sentence, yes, let's stay with the example and use \"host\" here. But I intended this sentence to be a possible explanation for the sentence before, so it's not really \"Additionally\".",
              "createdAt": "2021-02-17T03:08:02Z",
              "updatedAt": "2021-02-17T03:11:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkyNDI4NTEw",
          "commit": {
            "abbreviatedOid": "572139d"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-17T17:09:45Z",
          "updatedAt": "2021-02-17T17:09:45Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "The text looks good now",
              "createdAt": "2021-02-17T17:09:45Z",
              "updatedAt": "2021-02-17T17:09:45Z"
            }
          ]
        }
      ]
    },
    {
      "number": 45,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc1MDc5ODYy",
      "title": "Technology-specific terminology",
      "url": "https://github.com/panrg/path-properties/pull/45",
      "state": "MERGED",
      "author": "cyrill-k",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This text emphasizes that the terminology is intended to be general and applicable for a wide range of path aware technologies.",
      "createdAt": "2021-02-17T17:16:43Z",
      "updatedAt": "2021-02-22T16:20:38Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "be1387305d3715267f7a5d019afc445738edf6b8",
      "headRepository": "panrg/path-properties",
      "headRefName": "technology-specific-terminology",
      "headRefOid": "e85eef901647253ec9416c6b6d5acbe9e8519d76",
      "closedAt": "2021-02-22T16:20:38Z",
      "mergedAt": "2021-02-22T16:20:38Z",
      "mergedBy": "theri",
      "mergeCommit": {
        "oid": "adb9fa37ec5aa84a183a6a566fa9c374793f29c8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkyNzk2OTMy",
          "commit": {
            "abbreviatedOid": "25c7e29"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thank you for taking a stab at this! I like the content overall and I made a few suggestions on wording.",
          "createdAt": "2021-02-18T02:21:59Z",
          "updatedAt": "2021-02-18T02:41:14Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nThe terminology defined in this document is intended to be general and applicable to existing and future path-aware technologies.\r\n```\r\nI think \"define terminology\" is more fitting than \"describe terminology\" in this context. (Also, I'm getting 42.5k Google hits for \"define terminology\" and just 5.5k for \"describe terminology\" :smile:)",
              "createdAt": "2021-02-18T02:21:59Z",
              "updatedAt": "2021-02-22T16:19:37Z"
            },
            {
              "originalPosition": 7,
              "body": "I'm not sure about this sentence. Maybe we can delete it?\r\n\r\nThe introduction already gives the motivation for the common terminology:\r\n\"As terms related to paths have different meanings in different areas of networking, first, this document provides a common terminology to define paths, path elements, and path properties.\"\r\n\r\nAnd I'm not sure if we really unify existing terminology - we did survey existing terminology, but \"unify\" sounds like a stronger implication that what the doc actually does, and I'm not sure if we even \"attempt to unify\".\r\n\r\nIf we want to add motivation to this section, how about adding the following to the first sentence above?\r\n\"[\u2026] to provide a common language for the Path-Aware Networking Research Group.\"\r\nBecause I think that's actually the main motivation for having a generic common terminology that applies to different areas of networking.",
              "createdAt": "2021-02-18T02:28:24Z",
              "updatedAt": "2021-02-22T16:19:37Z"
            },
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nUsing this terminology, a path-aware technology can define and consider specific path elements and path properties on a specific level of abstraction.\r\n```\r\nIf the drop the second sentence, this sentence would follow after the first, so we can remove redundancy.\r\nAlso, added a \"specific\" to contrast with \"generic\".",
              "createdAt": "2021-02-18T02:29:53Z",
              "updatedAt": "2021-02-22T16:19:37Z"
            },
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nFor instance, a technology may define path elements as IP routers, e.g., in source routing ({{?RFC1940}}). Alternatively, it may consider path elements on a different layer of the Internet Architecture ({{?RFC1122}}) or independently, e.g., as a collection of entities, such as an AS or an ERO.\r\n```\r\n\r\nI think the original sentence listed different things that were not directly comparable, so I tried modifying it.\r\nAlso, as the previous sentence mentions \"path elements\" (and not \"paths\"), I think it's good to continue with path elements here.",
              "createdAt": "2021-02-18T02:39:21Z",
              "updatedAt": "2021-02-22T16:19:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk1MTA0MDA5",
          "commit": {
            "abbreviatedOid": "25c7e29"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-22T08:29:01Z",
          "updatedAt": "2021-02-22T08:29:01Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Agreed ;)",
              "createdAt": "2021-02-22T08:29:01Z",
              "updatedAt": "2021-02-22T16:19:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk1MTA1MzYw",
          "commit": {
            "abbreviatedOid": "25c7e29"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-22T08:30:53Z",
          "updatedAt": "2021-02-22T08:30:53Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Yes, I agree. Maybe it's better to delete this sentence",
              "createdAt": "2021-02-22T08:30:53Z",
              "updatedAt": "2021-02-22T16:19:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk1MTA4NDA1",
          "commit": {
            "abbreviatedOid": "25c7e29"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-22T08:35:00Z",
          "updatedAt": "2021-02-22T08:35:01Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "That sounds good.",
              "createdAt": "2021-02-22T08:35:00Z",
              "updatedAt": "2021-02-22T16:19:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk1MTE0MjYz",
          "commit": {
            "abbreviatedOid": "25c7e29"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-22T08:42:35Z",
          "updatedAt": "2021-02-22T08:42:36Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "> Also, as the previous sentence mentions \"path elements\" (and not \"paths\"), I think it's good to continue with path elements here.\r\n\r\nAgreed\r\n\r\nFor me using \"independently\" in this context is a bit confusing (I guess the meaning is independent from specific Internet Architecture layers). Maybe we can rephrase it?\r\n\r\n```suggestion\r\nFor instance, a technology may define path elements as IP routers, e.g., in source routing ({{?RFC1940}}). Alternatively, it may consider path elements on a different layer of the Internet Architecture ({{?RFC1122}}) or as a collection of entities not tied to a specific layer, such as an AS or an ERO.\r\n```",
              "createdAt": "2021-02-22T08:42:36Z",
              "updatedAt": "2021-02-22T16:19:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk1MTE3NTMz",
          "commit": {
            "abbreviatedOid": "25c7e29"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-22T08:46:40Z",
          "updatedAt": "2021-02-22T08:46:40Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\n```",
              "createdAt": "2021-02-22T08:46:40Z",
              "updatedAt": "2021-02-22T16:19:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk1NTI2Njcw",
          "commit": {
            "abbreviatedOid": "e85eef9"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks, this looks good to me now! Will merge and publish.",
          "createdAt": "2021-02-22T16:20:24Z",
          "updatedAt": "2021-02-22T16:20:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 50,
      "id": "MDExOlB1bGxSZXF1ZXN0Njc2NjkzOTYw",
      "title": "Add microscopic node example",
      "url": "https://github.com/panrg/path-properties/pull/50",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Add microscopic node example as suggested by Jake in #46.\r\nConsidered adding \"VPN node\", but not sure if this is really necessary, so decided to not do so for now, to keep the definition short.",
      "createdAt": "2021-06-24T00:00:24Z",
      "updatedAt": "2021-07-06T07:15:16Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "527929a1fd46f5059aac78004da52843a183c7dd",
      "headRepository": "panrg/path-properties",
      "headRefName": "theri/node-definition-microscopic",
      "headRefOid": "8fb44fdb6c53adec5778da7a604ead2c0bfe8f7d",
      "closedAt": "2021-07-06T07:15:16Z",
      "mergedAt": "2021-07-06T07:15:16Z",
      "mergedBy": "cyrill-k",
      "mergeCommit": {
        "oid": "156ad425bf2f73bae1dcd318408f2e01e62f56fb"
      },
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Merged current \"master\" with the updated entity and node definition into this branch.\r\nI think this can be merged now, right?",
          "createdAt": "2021-07-05T22:11:35Z",
          "updatedAt": "2021-07-05T22:11:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk4MDA5NzAx",
          "commit": {
            "abbreviatedOid": "f38963a"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I like this change to clarify the macroscopic concept, however I'd suggest to first resolve the entity definition issue and then incorporate this change.",
          "createdAt": "2021-07-02T09:37:39Z",
          "updatedAt": "2021-07-02T09:37:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 51,
      "id": "MDExOlB1bGxSZXF1ZXN0Njc2NzA4MzQx",
      "title": "Define \"entity\", be more deliberate in using entity VS node VS host, and traffic VS flows",
      "url": "https://github.com/panrg/path-properties/pull/51",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "When examining our use of \"entity\", I found that often we really mean anything that is either a node or measures path properties or processes them and potentially makes decisions based on them, e.g., path selection.\r\nTherefore, I kept \"entity\" in most places, but added a definition as suggested by Med.\r\n\r\nAlso chose terms more deliberately in the \"Path Selection\" section - paths can be selected by any entity, not just the communicating node. And \"traffic\" is undefined so I substituted it by \"flows\" when we really just mean flows... or \"data\" when the packet has not actually been created yet (i.e., before a protocol has been selected).",
      "createdAt": "2021-06-24T00:44:21Z",
      "updatedAt": "2021-07-05T21:59:52Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "adb9fa37ec5aa84a183a6a566fa9c374793f29c8",
      "headRepository": "panrg/path-properties",
      "headRefName": "theri/clarify-entity",
      "headRefOid": "4ffd68a2bd9782aa12365a72c052efe95d7fcd2c",
      "closedAt": "2021-07-05T21:59:52Z",
      "mergedAt": "2021-07-05T21:59:52Z",
      "mergedBy": "theri",
      "mergeCommit": {
        "oid": "527929a1fd46f5059aac78004da52843a183c7dd"
      },
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we are aligned now, so I'll merge.",
          "createdAt": "2021-07-05T21:59:27Z",
          "updatedAt": "2021-07-05T21:59:27Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk3OTY4MzM1",
          "commit": {
            "abbreviatedOid": "6b9872d"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I added some discussion in the terminology section about the new entity definition.",
          "createdAt": "2021-07-02T08:49:46Z",
          "updatedAt": "2021-07-02T09:33:43Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "We define:\r\n- an entity as \"a node or host\"\r\n- a node as an entity OR multiple entities\r\n\r\nThen I think we have an inconsistency (or at least a confusion) as a node is defined as both an entity and multiple entities. We could solve this by removing the examples \"node or host\".\r\n\r\nI would also suggest to remove the forward reference to flow as it is not necessary.",
              "createdAt": "2021-07-02T08:49:47Z",
              "updatedAt": "2021-07-02T09:33:43Z"
            },
            {
              "originalPosition": 5,
              "body": "Should we clarify that the capabilities of an entity listed here are non-exhaustive (since \"process packets (i.e., a node or host), measure path properties, or access information about paths\" might not cover every possibility).\r\n\r\nMaybe we can simply add \"for example\":\r\n\"A physical or virtual device or function which can for example process packets (i.e., a node or host), measure path properties, or access information about paths.\"",
              "createdAt": "2021-07-02T08:55:28Z",
              "updatedAt": "2021-07-02T09:33:43Z"
            },
            {
              "originalPosition": 25,
              "body": "Maybe we can rephrase this to clarify that these actions are not exclusive:\r\n\"Nodes may be able to send flows via one (or a subset) out of multiple possible paths and an entity may be able to influence the path selection.\"",
              "createdAt": "2021-07-02T09:07:37Z",
              "updatedAt": "2021-07-02T09:33:43Z"
            },
            {
              "originalPosition": 8,
              "body": "Actually, thinking about this discrepancy a bit more:\r\nSince we added a clear definition of entity, and a node is defined as a collection of entities, it means not every node is an entity.\r\nIn the current draft, whenever we mention \"entity\" in the draft, we want to include any possible node and host.\r\nNow, however, if we talk about an \"entity\" we only include nodes consisting of a single entity, which might not be what we want in many places of the text.\r\n\r\nI think we could solve this by:\r\n- changing the entity and node definition to ensure that every node is an entity (and include in the entity definition that an entity might consist of a collection of physical or virtual devices or functions).\r\n- whenever we talk about an \"entity\" in the text and want to include the definition of a node, we make sure that we say \"a node or an entity\". However I think this is not a very elegant solution.",
              "createdAt": "2021-07-02T09:32:23Z",
              "updatedAt": "2021-07-02T09:33:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk4NDkyMDI4",
          "commit": {
            "abbreviatedOid": "6b9872d"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-02T20:50:33Z",
          "updatedAt": "2021-07-02T20:50:33Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Thanks for catching this.\r\nI think the best way forward is to change the entity and node definition to ensure that every node is an entity.\r\nI was actually intending to make \"entities\" a superset of \"nodes\", i.e., an entity is broader than a node, because we need nodes to define a path, and an entity can be basically anything and doesn't have to be on the path.\r\n\r\nChanging the \"Entity\" definition now, and took a stab at simplifying the \"Node\" definition as well. I don't see the need to define a Node as a collection of entities now, as an entity can already be a collection. Do you agree?",
              "createdAt": "2021-07-02T20:50:33Z",
              "updatedAt": "2021-07-02T20:50:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk4NDkyNDYx",
          "commit": {
            "abbreviatedOid": "6b9872d"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-02T20:51:32Z",
          "updatedAt": "2021-07-02T20:51:32Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Good idea, will change.",
              "createdAt": "2021-07-02T20:51:32Z",
              "updatedAt": "2021-07-02T20:51:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk4NDkzNjE3",
          "commit": {
            "abbreviatedOid": "6b9872d"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-02T20:54:05Z",
          "updatedAt": "2021-07-02T20:54:06Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I'm not entirely convinced it said that the actions were exclusive, but I'm fine with shortening it a bit.\r\nI like \"influence\", but I didn't want to explain path selection with itself, so I went for \"influence the decision which path(s) to use\". Does this work?",
              "createdAt": "2021-07-02T20:54:06Z",
              "updatedAt": "2021-07-02T20:54:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk4OTM0NzEz",
          "commit": {
            "abbreviatedOid": "dc4d093"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-05T08:39:22Z",
          "updatedAt": "2021-07-05T08:39:22Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Yes, if we phrase it in this way then it should be clear.",
              "createdAt": "2021-07-05T08:39:22Z",
              "updatedAt": "2021-07-05T08:39:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk4OTM3MzM3",
          "commit": {
            "abbreviatedOid": "dc4d093"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-05T08:42:13Z",
          "updatedAt": "2021-07-05T08:42:13Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Yes, that sounds good",
              "createdAt": "2021-07-05T08:42:13Z",
              "updatedAt": "2021-07-05T08:42:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk4OTQzMjUx",
          "commit": {
            "abbreviatedOid": "dc4d093"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-05T08:48:32Z",
          "updatedAt": "2021-07-05T08:48:33Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "We should maybe clarify what the collection consists of:\r\n```suggestion\r\n: An entity which processes packets, e.g., sends, receives, forwards, or modifies them. A node may be physical or virtual, e.g., a physical device or a service function provided as a virtual element. A node may also be an entity which consists of a collection of devices or functions, e.g., an entire Autonomous System (AS).\r\n```",
              "createdAt": "2021-07-05T08:48:32Z",
              "updatedAt": "2021-07-05T09:18:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk5NDI4ODU0",
          "commit": {
            "abbreviatedOid": "dc4d093"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-05T21:56:51Z",
          "updatedAt": "2021-07-05T21:56:52Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "That works! Then it doesn't say anymore that the collection processes packets, but that's both already part of the definition and clear from the example.",
              "createdAt": "2021-07-05T21:56:52Z",
              "updatedAt": "2021-07-05T21:56:52Z"
            }
          ]
        }
      ]
    },
    {
      "number": 52,
      "id": "MDExOlB1bGxSZXF1ZXN0Njc2NzE0MTU2",
      "title": "Clarify context of Service Invocation use case, closes #49",
      "url": "https://github.com/panrg/path-properties/pull/52",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on Brian's comment at IETF 110, setting the context explicitly: We're talking about Service Function Chaining.",
      "createdAt": "2021-06-24T01:04:40Z",
      "updatedAt": "2021-07-02T08:16:43Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "adb9fa37ec5aa84a183a6a566fa9c374793f29c8",
      "headRepository": "panrg/path-properties",
      "headRefName": "theri/service-invocation",
      "headRefOid": "8f89ebbecb64bb58f54fef2f023683edc2cddf61",
      "closedAt": "2021-07-02T08:16:43Z",
      "mergedAt": "2021-07-02T08:16:43Z",
      "mergedBy": "cyrill-k",
      "mergeCommit": {
        "oid": "693934e433cc172d5e3fb919f5db89baf3afa1a2"
      },
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "This clarification looks good to me.",
          "createdAt": "2021-07-02T08:16:21Z",
          "updatedAt": "2021-07-02T08:16:21Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 53,
      "id": "MDExOlB1bGxSZXF1ZXN0NjgyNzE5ODIx",
      "title": "Slightly rephrase transparency definition and add more examples",
      "url": "https://github.com/panrg/path-properties/pull/53",
      "state": "MERGED",
      "author": "cyrill-k",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-07-02T15:35:11Z",
      "updatedAt": "2021-07-09T15:44:50Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "693934e433cc172d5e3fb919f5db89baf3afa1a2",
      "headRepository": "panrg/path-properties",
      "headRefName": "cyrill/transparency",
      "headRefOid": "9e181a353d9dddee93ecc2df56bf5ce124f89524",
      "closedAt": "2021-07-09T15:44:50Z",
      "mergedAt": "2021-07-09T15:44:50Z",
      "mergedBy": "theri",
      "mergeCommit": {
        "oid": "90f35cb16082d4787d9c1aa8db1d00bd72ead475"
      },
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'm not sure what to do about the \"endpoint transparency\" (\"host transparency\"?), or the explicit communication with a host.\r\nIf the node has communicated with the host, say, out-of-band, and then modifies the packet based on that, can that be just another piece of meta-information?\r\n\r\nI guess that is true, however even in such a case, the relevant piece of meta-information is how to **identify** the flow and associate it to host, with which the node communicated to perform a specific action.\r\nAnd the identification relies on the existence and content of protocol headers and payloads, which we cover with our definition.\r\nSo, for example to model RFC8558 style interactions between hosts and on-path nodes using our path terminology, we could say that the explicit communication with a host changes the transparency property of the node.\r\n\r\n> I'm not sure we should attempt to capture a broader concept of \"endpoint transparency\", e.g., whether an endpoint is aware of a particular node, and whether it communicates with the node explicitly. Maybe we can get away with just making this awareness or communication be \"meta-information\", which we don't define further?\r\n\r\nI would suggest to keep the definition as it is right now and keep the definition of meta-information open-ended.",
          "createdAt": "2021-07-05T09:17:15Z",
          "updatedAt": "2021-07-05T09:17:15Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with your reasoning regarding the \"endpoint transparency\" - let's keep the definition as-is.\r\n\r\nSo I think this PR can be merged after changing the firewall example. :slightly_smiling_face: ",
          "createdAt": "2021-07-05T22:07:41Z",
          "updatedAt": "2021-07-05T22:07:41Z"
        },
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "I changed the firewall example.\r\nIf you agree with the changes, you can merge the PR.",
          "createdAt": "2021-07-06T07:45:01Z",
          "updatedAt": "2021-07-06T07:45:01Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks good to me now, so I'm merging it.",
          "createdAt": "2021-07-09T15:44:45Z",
          "updatedAt": "2021-07-09T15:44:45Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk4NDk2NjU0",
          "commit": {
            "abbreviatedOid": "809e41d"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for these changes, I like them, and I have a few proposed tweaks.\r\n\r\nI'm not sure what to do about the \"endpoint transparency\" (\"host transparency\"?), or the explicit communication with a host.\r\nIf the node has communicated with the host, say, out-of-band, and then modifies the packet based on that, can that be just another piece of meta-information?\r\n\r\nI'm not sure we should attempt to capture a broader concept of \"endpoint transparency\", e.g., whether an endpoint is aware of a particular node, and whether it communicates with the node explicitly. Maybe we can get away with just making this awareness or communication be \"meta-information\", which we don't define further?",
          "createdAt": "2021-07-02T21:00:54Z",
          "updatedAt": "2021-07-02T21:28:25Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I found this sentence hard to parse.\r\nHow about something like:\r\n```suggestion\r\n: When a node performs an action on a flow, the node is transparent to the flow with respect to some (meta-)information if the node performs this action independently of the given (meta-)information.\r\n```",
              "createdAt": "2021-07-02T21:00:54Z",
              "updatedAt": "2021-07-02T21:28:25Z"
            },
            {
              "originalPosition": 29,
              "body": "Nit, I don't like sentences starting with \"And\" :)\r\n```suggestion\r\nFinally, a NAT that actively modifies IP and TCP/UDP header information based on their content is not transparent to either IP or TCP/UDP headers.\r\n```",
              "createdAt": "2021-07-02T21:03:55Z",
              "updatedAt": "2021-07-02T21:28:25Z"
            },
            {
              "originalPosition": 30,
              "body": "Nit, I don't think we need the hypothetical here, and the node is reacting, right? Or maybe \"acting on\"?\r\n```suggestion\r\nNote that according to this definition, a node that modifies packets in accordance with the hosts, such as a transparent HTTP proxy, as defined in {{RFC2616}}, and a node listening and reacting to implicit or explicit signals, see {{RFC8558}}, are not considered transparent.\r\n```",
              "createdAt": "2021-07-02T21:04:38Z",
              "updatedAt": "2021-07-02T21:28:25Z"
            },
            {
              "originalPosition": 28,
              "body": "If the firewall indeed does not look at the IP addresses at all, it would help to clarify the example, e.g.:\r\n```suggestion\r\nA TCP SYN flooding firewall that drops TCP SYN packets after having seen a certain number of packets with TCP SYN, regardless of IP address, is transparent to IP but not to TCP/UDP.\r\n```\r\n\r\nBut it doesn't sound like a good idea to implement it this way, as that means you could DoS a network by SYN-flooding it. \r\nSo perhaps this firewall should count TCP SYN packets from a particular IP address or for a combination of source and destination IP addresses, in which case it would not be transparent to either TCP or IP.\r\n\r\nWhat do you think?",
              "createdAt": "2021-07-02T21:13:31Z",
              "updatedAt": "2021-07-02T21:28:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk4OTUzMDA0",
          "commit": {
            "abbreviatedOid": "5d1b2fd"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-05T08:58:38Z",
          "updatedAt": "2021-07-05T08:58:39Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I wanted to have an example where a node is transparent to IP but not to TCP/UDP to show that such a combination is also possible.\r\nBut I agree that the example does not make much sense in practice ^^\r\n\r\nMaybe we could use the example of a firewall that only allows outgoing TCP connection, i.e., blocks all incoming TCP SYN packets regardless of the IP address?\r\nThat seems more reasonable.",
              "createdAt": "2021-07-05T08:58:39Z",
              "updatedAt": "2021-07-05T08:58:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njk5NDMwNTk3",
          "commit": {
            "abbreviatedOid": "ed43b76"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-05T22:04:29Z",
          "updatedAt": "2021-07-05T22:04:29Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Yep, sounds like this is a better example.",
              "createdAt": "2021-07-05T22:04:29Z",
              "updatedAt": "2021-07-05T22:04:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAxNTIwNzY5",
          "commit": {
            "abbreviatedOid": "cc143fc"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "The firewall example looks good, but I just tripped over the IP router example. Sorry, didn't see this earlier. And it might just be me missing something obvious...?",
          "createdAt": "2021-07-07T23:21:27Z",
          "updatedAt": "2021-07-07T23:22:44Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Just reading the whole thing again: Why does an IP router actively modify IP headers, whereby the text reads as if that's necessarily always the case?\r\nWouldn't the router just look up the destination address in its forwarding table and then forward the packet, modifying the Ethernet header for sure, but not the IP header?\r\nSorry, am I just missing something right now? :sweat_smile: ",
              "createdAt": "2021-07-07T23:21:27Z",
              "updatedAt": "2021-07-07T23:22:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAxNTIxNjEz",
          "commit": {
            "abbreviatedOid": "cc143fc"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-07T23:23:32Z",
          "updatedAt": "2021-07-07T23:23:32Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I guess the IP router reads these headers for sure, so the example wouldn't have to change much to say this.",
              "createdAt": "2021-07-07T23:23:32Z",
              "updatedAt": "2021-07-07T23:23:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAyNzczNDkz",
          "commit": {
            "abbreviatedOid": "cc143fc"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-09T07:46:13Z",
          "updatedAt": "2021-07-09T07:46:14Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I was thinking that the IP router changes certain IP header fields (e.g., TTL, IP checksum), however maybe we can make a better example by considering the action of \"forwarding on a certain interface\".\r\nWhat do you think?\r\n\r\n```suggestion\r\nAn IP router could be transparent to transport protocol headers such as TCP/UDP but not transparent to IP headers since its forwarding behavior depends on the IP headers.\r\n```",
              "createdAt": "2021-07-09T07:46:13Z",
              "updatedAt": "2021-07-09T07:46:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAzMTc5ODE5",
          "commit": {
            "abbreviatedOid": "cc143fc"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-09T15:44:09Z",
          "updatedAt": "2021-07-09T15:44:09Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I like your suggestion. And you're right, \"modify IP header\" doesn't necessarily mean addresses... but still I think your proposed wording is clearer.",
              "createdAt": "2021-07-09T15:44:09Z",
              "updatedAt": "2021-07-09T15:44:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 54,
      "id": "MDExOlB1bGxSZXF1ZXN0NjgyNzMxNDQ5",
      "title": "Add point-multipoint example to protocol feature property",
      "url": "https://github.com/panrg/path-properties/pull/54",
      "state": "CLOSED",
      "author": "cyrill-k",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "theri"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2021-07-02T15:54:58Z",
      "updatedAt": "2021-07-05T08:20:06Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "693934e433cc172d5e3fb919f5db89baf3afa1a2",
      "headRepository": "panrg/path-properties",
      "headRefName": "cyrill/point-multipoint",
      "headRefOid": "308e57c66496b85105fe2c02cdbe7b693123739c",
      "closedAt": "2021-07-05T08:20:06Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for taking a stab, but I don't think it really fits under \"protocol features\" - these were intended to be features of a single given protocol, which can be switched on or off. Replication efficiency, as outlined by Jake, appears to be more about differences between multiple solutions which all share the concept of replicating packets, but are otherwise very different protocols, and may even be tied to a specific physical link type.\r\n\r\nIn my reply I had asked about this property's relationship to a use case, and I have not gotten a reply.\r\nI am still not seeing a use case myself - I don't think it can be used for Path Selection, maybe it could have some relationship to Protocol Selection but it's not obvious to me and would need an example, and I don't think there's a relationship to Service Invocation.\r\nSo, we could leave it out for now and maybe ask Jake again what use case he had in mind?",
          "createdAt": "2021-07-02T23:05:34Z",
          "updatedAt": "2021-07-02T23:05:34Z"
        },
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "I think that is a good idea, let's leave it out for now :+1: ",
          "createdAt": "2021-07-05T08:19:57Z",
          "updatedAt": "2021-07-05T08:19:57Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 56,
      "id": "PR_kwDOCPnxh84tZp29",
      "title": "Expand and clarify entity definition",
      "url": "https://github.com/panrg/path-properties/pull/56",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR addresses #47 and #55 by explicitly stating a common aspect of all entities (in the scope of this document): They play a role related to path-aware networking for a particular path and flow.\r\nIt then illustrates these roles based on the clarified \"data plane\" and \"control plane\".\r\n\r\nNot sure if \"what may be called [data|control] plane\" is the right phrasing yet, but I didn't want to imply that one *has* to use these terms, or that the entity's role always has to align with any possible definition of these terms.\r\n\r\nPlease let me know what you think.",
      "createdAt": "2021-10-19T18:50:24Z",
      "updatedAt": "2021-10-21T18:19:04Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "90f35cb16082d4787d9c1aa8db1d00bd72ead475",
      "headRepository": "panrg/path-properties",
      "headRefName": "theri/control-data-plane",
      "headRefOid": "2efda9511425a2eb041980a03962adec4666ca50",
      "closedAt": "2021-10-21T18:19:04Z",
      "mergedAt": "2021-10-21T18:19:04Z",
      "mergedBy": "theri",
      "mergeCommit": {
        "oid": "93daa031b5cd5d2119cd423b38a99016097b118b"
      },
      "comments": [
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "I like the changes and I think its good to keep it as general as possible.\r\nI changed a few things:\r\n- Change \"control aspects\" -> \"influence aspects\" since the actual path control may be done by the endpoint not the control plane (although the name *control* plane seems to imply control so we can also keep \"control aspects\" ;D )\r\n- Change node definition to be an **on-path** entity because we want to actually use the abstract entity definitions (#47).\r\n- Also, I changed some occurrences of *node* to *entity* in the security considerations since it seems to be more general.\r\n\r\nWhat do you think?",
          "createdAt": "2021-10-21T09:02:46Z",
          "updatedAt": "2021-10-21T09:02:46Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you for these changes, I like them!\r\nI'll go ahead and merge this.",
          "createdAt": "2021-10-21T18:18:56Z",
          "updatedAt": "2021-10-21T18:18:56Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 57,
      "id": "PR_kwDOCPnxh84tetlM",
      "title": "Extend transparency definition to discuss evaluation of the property",
      "url": "https://github.com/panrg/path-properties/pull/57",
      "state": "MERGED",
      "author": "cyrill-k",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This pull request extends the definition of the transparency property based on the discussion mentioned in #25.\r\n\r\nMy own opinion on this PR:\r\n- I think it helps understand the transparency property better and makes it less abstract by giving examples of how it could be implemented in practice\r\n- However, the definition does not change with this PR and the definition is already quite long.\r\n\r\nSo, I would suggest to merge it but I'm also fine with leaving out the implementation details.",
      "createdAt": "2021-10-21T08:25:59Z",
      "updatedAt": "2021-10-24T22:45:45Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "90f35cb16082d4787d9c1aa8db1d00bd72ead475",
      "headRepository": "panrg/path-properties",
      "headRefName": "cyrill/transparency",
      "headRefOid": "cf83ea0c77ceee883f5843ed41ba81efbd534a6d",
      "closedAt": "2021-10-24T22:45:45Z",
      "mergedAt": "2021-10-24T22:45:45Z",
      "mergedBy": "cyrill-k",
      "mergeCommit": {
        "oid": "a060d2d1bff05f6acc2495ca02d309fd10514f07"
      },
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree it's useful here to have the definition a bit more formalized.\r\nHaving read up on what a \"taint analysis\"\u202fis, it seems a little odd to me to apply this concept to Transparency in this document, as the (meta-)information M is not really the same as \"insecure user input\". But if it helps others understand the property, I'm all for it.\r\n\r\nI have to admit I don't understand this part of Richard's comment though:\r\n> In your original doc (e.g., IP vs NAT example), it is the no-taint requirement, in that the function f does not access the metric. In PL/security, it is no taint.\r\n\r\nIsn't this one and the same thing, i.e., \"no-taint\"\u202fvs \"no taint\" in both parts of the sentence?\r\nOr is the difference that, with the updated definition, it doesn't matter if the node actually accesses M, as long as the result of f doesn't change?",
          "createdAt": "2021-10-21T18:29:07Z",
          "updatedAt": "2021-10-21T18:29:07Z"
        },
        {
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "body": "> Isn't this one and the same thing, i.e., \"no-taint\"\u202fvs \"no taint\" in both parts of the sentence?\r\nOr is the difference that, with the updated definition, it doesn't matter if the node actually accesses M, as long as the result of f doesn't change?\r\n\r\nI'm also not 100% sure what he meant but I think it is the same and he just wanted to say that this is called no taint requirement in the context of PL/security...\r\n\r\nI think the difference is meant with regards to my suggestion in the chat of having a constant function to model transparency.",
          "createdAt": "2021-10-24T22:45:14Z",
          "updatedAt": "2021-10-24T22:45:14Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCPnxh84u2mrJ",
          "commit": {
            "abbreviatedOid": "cf83ea0"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Left a comment just now that should've gone with an \"Approve\" :slightly_smiling_face: ",
          "createdAt": "2021-10-21T18:32:27Z",
          "updatedAt": "2021-10-21T18:32:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 63,
      "id": "PR_kwDOCPnxh84zTYFx",
      "title": "Add brief discussion of contexts in the draft",
      "url": "https://github.com/panrg/path-properties/pull/63",
      "state": "MERGED",
      "author": "cyrill-k",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I added two sentences about contexts.\r\nSee #62 ",
      "createdAt": "2022-02-22T18:36:51Z",
      "updatedAt": "2022-03-02T15:15:32Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "a060d2d1bff05f6acc2495ca02d309fd10514f07",
      "headRepository": "panrg/path-properties",
      "headRefName": "cyrill/context",
      "headRefOid": "a0739b48746eec6a3c129d6604dae304c0f47d55",
      "closedAt": "2022-03-02T15:15:32Z",
      "mergedAt": "2022-03-02T15:15:32Z",
      "mergedBy": "cyrill-k",
      "mergeCommit": {
        "oid": "29c8240f28ebfdebf8b650f8dd363a9d232603ca"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCPnxh841KeBG",
          "commit": {
            "abbreviatedOid": "1603a3b"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for the suggestion, I agree that a brief addition here is enough.\r\nHowever, I do have quite a few thoughts on the specifics.",
          "createdAt": "2022-02-24T03:13:49Z",
          "updatedAt": "2022-02-24T03:23:08Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Is it really the terminology that differs, or is it the specific definition you get when using this terminology, i.e., what specific component gets defined as a node/path/endpoint? (At least that's what the prior few sentences suggest, as I read them.)\r\n\r\nI'm wondering if this should say:\r\n```suggestion\r\nEven within a single path-aware technology, specific definitions might differ depending on the context in which they are used.\r\n```",
              "createdAt": "2022-02-24T03:13:49Z",
              "updatedAt": "2022-02-24T03:23:08Z"
            },
            {
              "originalPosition": 5,
              "body": "If our endpoint definition lands, we can change this to \"endpoint\".\r\n\r\nHowever, I'm not quite sure what \"the data-plane context\" and \"the control-plane context\" actually is. We do define data plane and control plane as part of the entity definition, but I still don't think these are necessarily clearly defined contexts. At least in my mind, a \"control-plane context\" could just as easily refer to routing between individual hosts and not just be on an AS level.\r\n\r\nAn easy fix would be to make it sound less like there is *the* single clearly defined \"control plane context\":\r\n\r\n```suggestion\r\nFor example, the endpoints might be the communicating hosts in a data-plane context, and the AS of the respective hosts in a control-plane context.\r\n```\r\n\r\nOr maybe we can change the example:\r\n\r\n```suggestion\r\nFor example, the endpoints might be the communicating hosts in the context of the transport layer, ASes that contain the hosts in the context of routing, or specific applications in the context of the application layer.\r\n```\r\n\r\nHowever, at this point, it feels like we're almost replicating the part of the Path definition which talks about levels of abstraction:\r\n\r\n> Path: [\u2026] Different entities may have different visibility of a path and/or treat path elements at different levels of abstraction. For example, a path may be given as a sequence of physical nodes and the links connecting these nodes, or it may be given as a sequence of logical nodes such as a sequence of ASes or an Explicit Route Object (ERO). Similarly, the representation of a path and its properties, as it is known to a specific entity, may be more complex and include details about the physical layer technology, or it may be more abstract and only consist of a specific source and destination which is known to be reachable from that source.\r\n\r\nBut maybe that's fine, as the point is important enough that it bears repeating, as we keep getting comments about it...? :slightly_smiling_face: \r\n(And no, I don't want this document to define \"transport layer\" or \"routing\"...)",
              "createdAt": "2022-02-24T03:16:51Z",
              "updatedAt": "2022-02-24T03:23:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCPnxh841XNFF",
          "commit": {
            "abbreviatedOid": "67233c4"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-28T15:59:17Z",
          "updatedAt": "2022-02-28T15:59:18Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "An advantage of the second proposal is that it shows that an endpoint can also be a virtual entity, such as an application, on a host (not only the host itself). Also, it does not suffer from the fact that a reader may think, there are only two contexts, i.e., data-plane vs control-plane.\r\n\r\nI would suggest to use the second proposal (even if the text is somewhat redundant, in my opinion it still helps with understanding).",
              "createdAt": "2022-02-28T15:59:18Z",
              "updatedAt": "2022-02-28T15:59:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCPnxh841cvmW",
          "commit": {
            "abbreviatedOid": "67233c4"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-01T19:23:33Z",
          "updatedAt": "2022-03-01T19:23:33Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Ok, sounds good! Let's go with the second proposal then.",
              "createdAt": "2022-03-01T19:23:33Z",
              "updatedAt": "2022-03-01T19:23:33Z"
            }
          ]
        }
      ]
    },
    {
      "number": 64,
      "id": "PR_kwDOCPnxh84zYWlq",
      "title": "Define \"endpoint\" and \"end-to-end\"",
      "url": "https://github.com/panrg/path-properties/pull/64",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed, this PR adds definitions for \"endpoint\" and \"end-to-end\", whereby I thought the \"end-to-end\" definition fits well under the later heading and doesn't need to be under our \"core\" definitions.\r\n\r\nI think all occurrences of \"host\" can be safely substituted by \"endpoint\", and indeed should be, because surely a non-host endpoint can perform path selection as well as a host can :slightly_smiling_face: \r\nIn the 0-RTT Transport Converter, \"host\" and \"endpoint\" appear to be used as synonyms, so I think it's fine to switch \"endpoint\" here, too, though we could always go back to using \"host\", which is an example of an endpoint.\r\n\r\nI'm also adding a few more acknowledgments, so now that section includes everyone who has reviewed the doc and made substantial comments in these reviews. Shall we also include everyone who has made substantial comments at the mic? Please point it out if you think I have missed someone.",
      "createdAt": "2022-02-24T03:02:16Z",
      "updatedAt": "2022-03-01T19:30:00Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "a060d2d1bff05f6acc2495ca02d309fd10514f07",
      "headRepository": "panrg/path-properties",
      "headRefName": "theri/define-endpoint",
      "headRefOid": "fce42842d6fda980d7ab5f9e5603eef407d152bc",
      "closedAt": "2022-03-01T19:29:59Z",
      "mergedAt": "2022-03-01T19:29:59Z",
      "mergedBy": "theri",
      "mergeCommit": {
        "oid": "4e41493aa5563aaf2fe0f1302ade6ef0542003b3"
      },
      "comments": [
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Having made the requested change, I'll go ahead and merge this, as another change depends on it.",
          "createdAt": "2022-03-01T19:29:52Z",
          "updatedAt": "2022-03-01T19:29:52Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOCPnxh841XQnj",
          "commit": {
            "abbreviatedOid": "5168510"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "This PR looks good to me (except one occurrence of host, which we may want to keep).\r\nI think it covers all points discussed in the issues.",
          "createdAt": "2022-02-28T16:10:23Z",
          "updatedAt": "2022-02-28T16:24:15Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Should we keep the term host here?\r\n-  RFC 1122, which defines the terms transport layer and TCP/UDP, also uses the the term host to refer to the endpoints.\r\n- An endpoint might not necessarily know about its IP address or port number, for example if the endpoint is an application.\r\n\r\n```suggestion\r\n: One or multiple packets to which the traits of a path or set of subpaths may be applied in a functional sense. For example, a flow can consist of all packets sent within a TCP session with the same five-tuple between two hosts, or it can consist of all packets sent on the same physical link.\r\n```",
              "createdAt": "2022-02-28T16:10:23Z",
              "updatedAt": "2022-02-28T16:24:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCPnxh841cv2K",
          "commit": {
            "abbreviatedOid": "5168510"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-01T19:24:40Z",
          "updatedAt": "2022-03-01T19:24:40Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Agreed, these are good reasons to keep \"host\" here.",
              "createdAt": "2022-03-01T19:24:40Z",
              "updatedAt": "2022-03-01T19:24:40Z"
            }
          ]
        }
      ]
    },
    {
      "number": 65,
      "id": "PR_kwDOCPnxh84zYgls",
      "title": "Add \"Discussion venues\" section",
      "url": "https://github.com/panrg/path-properties/pull/65",
      "state": "MERGED",
      "author": "theri",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It took me a while to figure out, but this PR adds a \"Discussion venues\" section to the draft, pointing to the Github repo and mailing list.\r\n\r\nFor future reference, what I recall doing was:\r\n\r\n1. Copy the entire repo to a new directory (while already being on this branch)\r\n2. `cd lib && git pull` to update the template repo\r\n3. `make`, and then switch to using a \"main\" branch as advised by the output\r\n4. Make sure I have no uncommited changes and that I am on master (I don't understand why being on master is a requirement)\r\n5. `make -f lib/setup.mk` (which creates a commit)\r\n6. Manually edit .note.xml to actually contain the correct URL and a pointer to the mailing list, similar to [Spencer's example](https://github.com/SpencerDawkins/sdp-rtp-quic-questions/blob/main/.note.xml)\r\n7. Commit the changed .note.mk to \"master\". (Do not push)\r\n8. Switch back to my branch and cherry-pick both commits from \"master\"\r\n9. `make clean && make` -> Finally, the \"Discussion venues\" section shows up in the generated .txt and .html file\r\n10. Commit and push the changes to this branch\r\n\r\nMaybe there was an easier way to \"update\" a draft that was started before this feature existed, but I did not find it.",
      "createdAt": "2022-02-24T04:35:47Z",
      "updatedAt": "2022-03-01T19:16:23Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "a060d2d1bff05f6acc2495ca02d309fd10514f07",
      "headRepository": "panrg/path-properties",
      "headRefName": "theri/add-repo-pointer",
      "headRefOid": "764d7e4642eb50f0c2012baebb56e50118247ff0",
      "closedAt": "2022-03-01T19:16:23Z",
      "mergedAt": "2022-03-01T19:16:22Z",
      "mergedBy": "theri",
      "mergeCommit": {
        "oid": "780785ce095ad6e46ed6794dcdc8bc2c3a82a0a6"
      },
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "I'm sorry you had to go through all of that.  I didn't really realize just how awkward this experience might be.\r\n\r\nConveniently, this draft uses krandowm-rfc, so `make update-venue` likely would have worked for you, with a fair bit less effort involved.",
          "createdAt": "2022-02-25T00:35:42Z",
          "updatedAt": "2022-02-25T00:35:42Z"
        },
        {
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, I had no idea `make update-venue` existed, and I wasn't aware of the \"make update-* features\" in general. That would be a good addition to the documentation for the tools. :slightly_smiling_face: \r\n(I found that the CODEOWNERS file does say that it can be regenerated with `make update-codeowners` -\u202fI wonder if a similar comment could be added to other places where things can be regenerated. In case of the .note.mk, I had no file to start with - but I did look at Spencer's file and wondered how he generated it.)",
          "createdAt": "2022-02-26T03:27:27Z",
          "updatedAt": "2022-02-26T03:27:27Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "https://github.com/martinthomson/i-d-template/blob/main/doc/UPDATE.md is a start on documenting that.",
          "createdAt": "2022-02-28T00:18:00Z",
          "updatedAt": "2022-02-28T00:18:00Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 66,
      "id": "PR_kwDOCPnxh84zrdtH",
      "title": "Rephrase administrative domain and add routing domain identifier definition",
      "url": "https://github.com/panrg/path-properties/pull/66",
      "state": "MERGED",
      "author": "cyrill-k",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I rephrased the definition of administrative domain and added a definition for routing domain identifier as discussed in #58.\r\n\r\nI'm wondering if it may be more elegant to define \"routing domain\" and then only mention its identifier in this definition:\r\n\"A routing domain is an administrative domain, in which all path elements use a common routing protocol to communicate with each other.\r\nThe routing domain identifier is a unique identifier of a routing domain.\r\nAn example of a routing domain identifier is the globally unique autonomous system number (ASN) as defined in {{RFC1930}}.\"\r\n\r\nWhat do you think?",
      "createdAt": "2022-02-28T17:39:37Z",
      "updatedAt": "2022-03-07T16:28:40Z",
      "baseRepository": "panrg/path-properties",
      "baseRefName": "master",
      "baseRefOid": "a060d2d1bff05f6acc2495ca02d309fd10514f07",
      "headRepository": "panrg/path-properties",
      "headRefName": "cyrill/routing-domain-identifier",
      "headRefOid": "8d0587a3a86a9271c5e2fd64a5b2a0bf0503c0e0",
      "closedAt": "2022-03-07T16:28:40Z",
      "mergedAt": "2022-03-07T16:28:39Z",
      "mergedBy": "cyrill-k",
      "mergeCommit": {
        "oid": "17283e023e53c90e5c02c9629632a71def6180b1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOCPnxh841cykT",
          "commit": {
            "abbreviatedOid": "2c11b3f"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for the PR!\r\n\r\nI intentionally wanted this to be \"routing domain identifier\" instead of just \"routing domain\" because these are examples of path properties (as per the section heading).\r\nA path property, as defined, is a trait of one or multiple path elements. If I think of \"annotating\" one or more path elements with a path property, I would annotate them with a \"routing domain identifier\", I don't think I could annotate them with a \"routing domain\". If it's a routing domain, not identifier, to me it sounds like we're talking about some abstract notion of \"grouping path elements\" as a concept separate from path properties, instead of simply giving examples of path properties.\r\nIn other words, I would like these to clearly be examples of a path property that can be a trait of one or more path elements, instead of trying to define some concept of aggregations of path properties, which I think would confuse people.\r\n\r\nDoes that make sense to you?\r\nMaybe the distinction is all in my head... :sweat_smile: ",
          "createdAt": "2022-03-01T19:36:32Z",
          "updatedAt": "2022-03-01T19:48:24Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Thinking about the difference between \"Administrative Domain\" and \"Routing Domain Identifier\":\r\nMaybe the example of the administrative domain would be an identifier for the IGP area, owner of the AS, or service provider network?\r\n\r\nOf course, we could just make this property an \"Administrative domain identifier\".",
              "createdAt": "2022-03-01T19:36:32Z",
              "updatedAt": "2022-03-01T19:49:11Z"
            },
            {
              "originalPosition": 19,
              "body": "I think here it would be fine to say the following, to make it more of a definition (i.e., these are necessary requirements for path elements to be in the same routing domain, instead of merely statements that are true for some path elements in the same routing domain).\r\nAnd I think we can still put it like this, even if we keep this an \"identifier\".\r\n\r\n```suggestion\r\nPath elements in the same routing domain are in the same administrative domain and use a common routing protocol to communicate with each other.\r\n```",
              "createdAt": "2022-03-01T19:37:14Z",
              "updatedAt": "2022-03-01T19:48:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCPnxh841gg95",
          "commit": {
            "abbreviatedOid": "2c11b3f"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-02T15:12:35Z",
          "updatedAt": "2022-03-02T15:12:35Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I don't think there is a common type of identifiers for administrative domains. This is unlike the routing domain identifier property, which has a clearly defined semantics that is used by all routing domains to coordinate the routing between them.\r\nAdministrative domain seems more abstract and may not always have an identifier. However, I suppose it must have an identity to be a useful property ;D\r\n\r\nI'm not sure how to include the word identity though...",
              "createdAt": "2022-03-02T15:12:35Z",
              "updatedAt": "2022-03-02T15:12:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCPnxh841ghHB",
          "commit": {
            "abbreviatedOid": "2c11b3f"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-02T15:12:58Z",
          "updatedAt": "2022-03-02T15:12:59Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I like this suggestion.",
              "createdAt": "2022-03-02T15:12:59Z",
              "updatedAt": "2022-03-02T15:12:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCPnxh841giaF",
          "commit": {
            "abbreviatedOid": "dca7cd7"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-02T15:16:40Z",
          "updatedAt": "2022-03-02T15:16:41Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Do you have any suggestions how to integrate it?",
              "createdAt": "2022-03-02T15:16:40Z",
              "updatedAt": "2022-03-02T15:16:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCPnxh841hn6e",
          "commit": {
            "abbreviatedOid": "dca7cd7"
          },
          "author": "theri",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I think this can now be merged as-is, or we can add the \"identity\".",
          "createdAt": "2022-03-02T18:40:42Z",
          "updatedAt": "2022-03-02T18:42:20Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "(Responding to the above question, but having to \"comment\" on two lines to make the suggestion work)\r\n\r\nGood point that identifiers for administrative domain are less clearly defined. Perhaps we can leave this as \"Administrative domain\", and then defining an administrative domain implies providing some kind of identifier or identity that refers to the individual or organization that owns the path element(s) - at least that's the only way I see how one would do that.\r\n\r\nIf we want to include the word \"identity\", how about:\r\n```suggestion\r\n: The identity of an individual or an organization that owns a path element (or several path elements).\r\nExamples of administrative domains are an IGP area, an AS, or a service provider network.\r\n```",
              "createdAt": "2022-03-02T18:40:42Z",
              "updatedAt": "2022-03-02T18:42:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOCPnxh841wnOp",
          "commit": {
            "abbreviatedOid": "dca7cd7"
          },
          "author": "cyrill-k",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-07T16:27:07Z",
          "updatedAt": "2022-03-07T16:27:07Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Yes, I think that is a good compromise.",
              "createdAt": "2022-03-07T16:27:07Z",
              "updatedAt": "2022-03-07T16:27:07Z"
            }
          ]
        }
      ]
    }
  ]
}